{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"dimtensor","text":"<p>Unit-aware tensors for physics and scientific machine learning.</p> <p>dimtensor wraps NumPy arrays with physical unit tracking, catching dimensional errors at operation time rather than after hours of computation.</p>"},{"location":"#why-dimtensor","title":"Why dimtensor?","text":"<ul> <li>Catch errors early: Don't waste compute on dimensionally invalid calculations</li> <li>Self-documenting code: Units make physics code clearer</li> <li>NumPy compatible: Works seamlessly with existing NumPy code</li> <li>Lightweight: Just metadata tracking, minimal overhead</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dimtensor import DimArray, units\n\n# Create dimension-aware arrays\nvelocity = DimArray([10, 20, 30], units.m / units.s)\ntime = DimArray([1, 2, 3], units.s)\n\n# Operations preserve/check dimensions\ndistance = velocity * time\nprint(distance)  # [10 40 90] m\n\n# Catch errors early\nacceleration = DimArray([9.8], units.m / units.s**2)\nvelocity + acceleration  # DimensionError: cannot add m/s to m/s^2\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dimtensor\n</code></pre>"},{"location":"#features","title":"Features","text":"Feature Description Dimensional Safety Operations between incompatible dimensions raise <code>DimensionError</code> Unit Conversion Convert between compatible units with <code>.to()</code> SI Units Full support for SI base and derived units Unit Simplification <code>kg*m/s^2</code> automatically displays as <code>N</code> NumPy Integration Works with ufuncs like <code>np.sin</code>, <code>np.sqrt</code> Array Functions <code>concatenate</code>, <code>stack</code>, <code>split</code>, <code>dot</code>, <code>matmul</code>, <code>norm</code>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Working with Units - Learn about the unit system</li> <li>Examples - Real-world physics calculations</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to dimtensor.</p>"},{"location":"changelog/#031-2026-01-08","title":"[0.3.1] - 2026-01-08","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentation site: Full mkdocs documentation with Material theme</li> <li>Display configuration: New <code>config</code> module for controlling output</li> <li><code>config.set_display(precision=N)</code> - set display precision</li> <li><code>config.precision(N)</code> - context manager for temporary precision</li> <li><code>config.options(...)</code> - context manager for multiple options</li> <li><code>config.reset_display()</code> - reset to defaults</li> </ul>"},{"location":"changelog/#030-2026-01-08","title":"[0.3.0] - 2026-01-08","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Module-level array functions (NumPy-style API):</li> <li><code>concatenate(arrays, axis)</code> - join arrays along existing axis</li> <li><code>stack(arrays, axis)</code> - join arrays along new axis</li> <li><code>split(array, indices_or_sections, axis)</code> - split array into sub-arrays</li> <li>Linear algebra functions:</li> <li><code>dot(a, b)</code> - dot product with dimension multiplication</li> <li><code>matmul(a, b)</code> - matrix multiplication with dimension multiplication</li> <li><code>norm(array, ord, axis, keepdims)</code> - vector/matrix norm, preserves units</li> <li>Reshaping methods on DimArray:</li> <li><code>reshape(shape)</code> - reshape preserving units</li> <li><code>transpose(axes)</code> - permute dimensions preserving units</li> <li><code>flatten()</code> - flatten to 1D preserving units</li> <li>Statistics method:</li> <li><code>var(axis, keepdims)</code> - variance with squared units (m -&gt; m^2)</li> <li>Searching methods:</li> <li><code>argmin(axis)</code> - return indices of minimum values</li> <li><code>argmax(axis)</code> - return indices of maximum values</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Array functions enforce same dimension for all input arrays</li> <li>Linear algebra functions properly multiply dimensions (L * L = L^2)</li> </ul>"},{"location":"changelog/#020-2025-01-08","title":"[0.2.0] - 2025-01-08","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Unit simplification: Compound units now display as their SI derived equivalents</li> <li><code>kg*m/s^2</code> -&gt; <code>N</code> (newton)</li> <li><code>kg*m^2/s^2</code> -&gt; <code>J</code> (joule)</li> <li><code>kg*m^2/s^3</code> -&gt; <code>W</code> (watt)</li> <li><code>m/s*s</code> -&gt; <code>m</code> (cancellation)</li> <li>Format string support: Use f-strings with DimArray</li> <li><code>f\"{distance:.2f}\"</code> -&gt; <code>\"1234.57 m\"</code></li> <li><code>f\"{energy:.2e}\"</code> -&gt; <code>\"1.23e+03 J\"</code></li> <li>NumPy ufunc integration: Use numpy functions directly</li> <li><code>np.sin(angle)</code>, <code>np.cos(angle)</code> - require dimensionless input</li> <li><code>np.exp(x)</code>, <code>np.log(x)</code> - require dimensionless input</li> <li><code>np.sqrt(area)</code> - halves dimension exponents</li> <li><code>np.abs(velocity)</code> - preserves units</li> <li><code>np.add(a, b)</code>, <code>np.multiply(a, b)</code> - dimension-aware arithmetic</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Unit display now uses simplified symbols by default</li> </ul>"},{"location":"changelog/#012-2025-01-08","title":"[0.1.2] - 2025-01-08","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Corrected GitHub repository URLs in PyPI metadata</li> </ul>"},{"location":"changelog/#011-2025-01-08","title":"[0.1.1] - 2025-01-08","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li><code>sqrt()</code> method on DimArray for square root with proper dimension handling</li> </ul>"},{"location":"changelog/#010-2025-01-08","title":"[0.1.0] - 2025-01-08","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Initial release</li> <li><code>DimArray</code> class wrapping numpy arrays with unit metadata</li> <li><code>Dimension</code> class with full algebra (multiply, divide, power)</li> <li>SI base units: meter, kilogram, second, ampere, kelvin, mole, candela</li> <li>SI derived units: newton, joule, watt, pascal, volt, hertz, etc.</li> <li>Common non-SI units: km, mile, hour, eV, atm, etc.</li> <li>Unit conversion with <code>.to()</code> method</li> <li>Dimensional error catching at operation time</li> <li>Arithmetic operations with automatic dimension checking</li> <li>Comparison operations between compatible dimensions</li> <li>Array indexing, slicing, and iteration</li> <li>Reduction operations (sum, mean, std, min, max)</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install dimtensor from PyPI:</p> <pre><code>pip install dimtensor\n</code></pre> <p>For development:</p> <pre><code>pip install dimtensor[dev]\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-dimarrays","title":"Creating DimArrays","text":"<p>A <code>DimArray</code> is a NumPy array with an attached physical unit:</p> <pre><code>from dimtensor import DimArray, units\n\n# From a list\nvelocity = DimArray([10, 20, 30], units.m / units.s)\n\n# From a NumPy array\nimport numpy as np\ndata = np.array([1.0, 2.0, 3.0])\ndistance = DimArray(data, units.km)\n\n# Scalar values\nmass = DimArray(5.0, units.kg)\n</code></pre>"},{"location":"getting-started/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Operations automatically track dimensions:</p> <pre><code># Multiplication combines dimensions\nforce = mass * DimArray([9.8], units.m / units.s**2)\nprint(force)  # 49.0 N\n\n# Addition requires same dimensions\na = DimArray([1, 2], units.m)\nb = DimArray([3, 4], units.m)\nprint(a + b)  # [4 6] m\n\n# Incompatible dimensions raise errors\nc = DimArray([1], units.s)\na + c  # DimensionError!\n</code></pre>"},{"location":"getting-started/#unit-conversion","title":"Unit Conversion","text":"<p>Convert between compatible units:</p> <pre><code>distance = DimArray([1.0], units.km)\n\n# Convert to meters\nin_meters = distance.to(units.m)\nprint(in_meters)  # [1000.] m\n\n# Convert to miles\nin_miles = distance.to(units.mile)\nprint(in_miles)  # [0.62137119] mi\n</code></pre>"},{"location":"getting-started/#accessing-data","title":"Accessing Data","text":"<pre><code>arr = DimArray([1, 2, 3], units.m)\n\n# Get the underlying NumPy array (read-only)\narr.data  # array([1, 2, 3])\n\n# Get the unit\narr.unit  # Unit(m)\n\n# Array properties\narr.shape  # (3,)\narr.ndim   # 1\narr.size   # 3\narr.dtype  # dtype('int64')\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<ul> <li>Working with Units - Available units and creating custom units</li> <li>Array Operations - Reshaping, linear algebra, and more</li> <li>Examples - Real physics calculations</li> </ul>"},{"location":"api/dimarray/","title":"DimArray","text":"<p>The core class for dimension-aware arrays.</p>"},{"location":"api/dimarray/#overview","title":"Overview","text":"<p><code>DimArray</code> wraps a NumPy array and tracks its physical dimensions through all operations. Operations between incompatible dimensions raise <code>DimensionError</code> immediately.</p> <pre><code>from dimtensor import DimArray, units\n\n# Create a DimArray\nvelocity = DimArray([10, 20, 30], units.m / units.s)\n</code></pre>"},{"location":"api/dimarray/#api-reference","title":"API Reference","text":""},{"location":"api/dimarray/#dimtensor.DimArray","title":"<code>DimArray</code>","text":"<p>A numpy array with attached physical units.</p> <p>DimArray wraps a numpy array and tracks its physical dimensions through all arithmetic operations. Operations between incompatible dimensions raise DimensionError immediately, catching physics errors early.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from dimtensor import DimArray, units\n&gt;&gt;&gt; v = DimArray([1.0, 2.0, 3.0], units.m / units.s)\n&gt;&gt;&gt; t = DimArray([0.5, 1.0, 1.5], units.s)\n&gt;&gt;&gt; d = v * t  # distance in meters\n&gt;&gt;&gt; print(d)\n[0.5 2.0 4.5] m\n</code></pre> <pre><code>&gt;&gt;&gt; a = DimArray([9.8], units.m / units.s**2)\n&gt;&gt;&gt; v + a  # raises DimensionError\n</code></pre>"},{"location":"api/dimarray/#dimtensor.DimArray.data","title":"<code>data: NDArray[Any]</code>  <code>property</code>","text":"<p>The underlying numpy array (read-only view).</p>"},{"location":"api/dimarray/#dimtensor.DimArray.unit","title":"<code>unit: Unit</code>  <code>property</code>","text":"<p>The physical unit of this array.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.dimension","title":"<code>dimension: Dimension</code>  <code>property</code>","text":"<p>The physical dimension of this array.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Shape of the underlying array.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Number of dimensions.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Total number of elements.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.dtype","title":"<code>dtype: np.dtype[Any]</code>  <code>property</code>","text":"<p>Data type of the underlying array.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.is_dimensionless","title":"<code>is_dimensionless: bool</code>  <code>property</code>","text":"<p>Check if this array is dimensionless.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.__init__","title":"<code>__init__(data: ArrayLike, unit: Unit | None = None, dtype: DTypeLike = None, copy: bool = False, uncertainty: ArrayLike | None = None) -&gt; None</code>","text":"<p>Create a DimArray.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ArrayLike</code> <p>Array-like data (list, tuple, numpy array, or scalar).</p> required <code>unit</code> <code>Unit | None</code> <p>Physical unit of the data. If None, assumes dimensionless.</p> <code>None</code> <code>dtype</code> <code>DTypeLike</code> <p>Numpy dtype for the underlying array.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If True, always copy the data.</p> <code>False</code> <code>uncertainty</code> <code>ArrayLike | None</code> <p>Optional absolute uncertainty (same shape as data).</p> <code>None</code>"},{"location":"api/dimarray/#dimtensor.DimArray.to","title":"<code>to(unit: Unit) -&gt; DimArray</code>","text":"<p>Convert to a different unit with the same dimension.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>Target unit (must have same dimension).</p> required <p>Returns:</p> Type Description <code>DimArray</code> <p>New DimArray with converted values and new unit.</p> <code>DimArray</code> <p>Uncertainty is scaled by the same conversion factor.</p> <p>Raises:</p> Type Description <code>UnitConversionError</code> <p>If dimensions don't match.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.to_base_units","title":"<code>to_base_units() -&gt; DimArray</code>","text":"<p>Convert to SI base units.</p> <p>Returns a DimArray with scale factor 1.0 (pure SI units). Uncertainty is scaled accordingly.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.magnitude","title":"<code>magnitude() -&gt; NDArray[Any]</code>","text":"<p>Return the numerical magnitude (stripping units).</p> <p>Use with caution - this loses dimensional safety.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.sum","title":"<code>sum(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Sum of array elements.</p> <p>Uncertainty propagation: sigma_sum = sqrt(sum(sigma_i^2))</p>"},{"location":"api/dimarray/#dimtensor.DimArray.mean","title":"<code>mean(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Mean of array elements.</p> <p>Uncertainty propagation: sigma_mean = sqrt(sum(sigma_i^2)) / N</p>"},{"location":"api/dimarray/#dimtensor.DimArray.std","title":"<code>std(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Standard deviation of array elements.</p> <p>Note: Uncertainty propagation through std is complex and not implemented. The result will have no uncertainty information.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.var","title":"<code>var(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Variance of array elements.</p> <p>Note: Variance has units squared (e.g., m -&gt; m^2). Uncertainty propagation through variance is not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int | None</code> <p>Axis along which to compute variance.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If True, reduced dimensions are kept with size 1.</p> <code>False</code> <p>Returns:</p> Type Description <code>DimArray</code> <p>Variance with squared unit.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.min","title":"<code>min(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Minimum value.</p> <p>Uncertainty: takes uncertainty of the minimum element.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.max","title":"<code>max(axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Maximum value.</p> <p>Uncertainty: takes uncertainty of the maximum element.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.argmin","title":"<code>argmin(axis: int | None = None) -&gt; np.intp | NDArray[np.intp]</code>","text":"<p>Return indices of minimum values.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int | None</code> <p>Axis along which to find minimum. If None, returns index into flattened array.</p> <code>None</code> <p>Returns:</p> Type Description <code>intp | NDArray[intp]</code> <p>Index or array of indices (dimensionless integers).</p>"},{"location":"api/dimarray/#dimtensor.DimArray.argmax","title":"<code>argmax(axis: int | None = None) -&gt; np.intp | NDArray[np.intp]</code>","text":"<p>Return indices of maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int | None</code> <p>Axis along which to find maximum. If None, returns index into flattened array.</p> <code>None</code> <p>Returns:</p> Type Description <code>intp | NDArray[intp]</code> <p>Index or array of indices (dimensionless integers).</p>"},{"location":"api/dimarray/#dimtensor.DimArray.reshape","title":"<code>reshape(shape: tuple[int, ...] | list[int]) -&gt; DimArray</code>","text":"<p>Return a reshaped array with the same unit.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple[int, ...] | list[int]</code> <p>New shape. One dimension may be -1, which is inferred.</p> required <p>Returns:</p> Type Description <code>DimArray</code> <p>Reshaped DimArray with same unit and reshaped uncertainty.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.transpose","title":"<code>transpose(axes: tuple[int, ...] | list[int] | None = None) -&gt; DimArray</code>","text":"<p>Permute the dimensions of the array.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple[int, ...] | list[int] | None</code> <p>Permutation of dimensions. If None, reverses dimensions.</p> <code>None</code> <p>Returns:</p> Type Description <code>DimArray</code> <p>Transposed DimArray with same unit.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.flatten","title":"<code>flatten() -&gt; DimArray</code>","text":"<p>Return a 1D flattened copy of the array.</p> <p>Returns:</p> Type Description <code>DimArray</code> <p>Flattened DimArray with same unit.</p>"},{"location":"api/dimarray/#dimtensor.DimArray.sqrt","title":"<code>sqrt() -&gt; DimArray</code>","text":"<p>Square root (dimension exponents halve).</p>"},{"location":"api/functions/","title":"Functions","text":"<p>Module-level functions for array operations.</p>"},{"location":"api/functions/#array-manipulation","title":"Array Manipulation","text":""},{"location":"api/functions/#concatenate","title":"concatenate","text":"<p>Join arrays along an existing axis.</p> <pre><code>from dimtensor import DimArray, units, concatenate\n\na = DimArray([1, 2], units.m)\nb = DimArray([3, 4], units.m)\nresult = concatenate([a, b])  # [1 2 3 4] m\n</code></pre> <p>All arrays must have the same dimension. Arrays with compatible units are converted to the first array's unit.</p>"},{"location":"api/functions/#dimtensor.concatenate","title":"<code>concatenate(arrays: Sequence[DimArray], axis: int = 0) -&gt; DimArray</code>","text":"<p>Join a sequence of DimArrays along an existing axis.</p> <p>All arrays must have the same unit dimension. Arrays with compatible units (e.g., km and m) will be converted to the first array's unit.</p> <p>If any arrays have uncertainty, the uncertainties are concatenated. Arrays without uncertainty are treated as having zero uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[DimArray]</code> <p>Sequence of DimArrays to concatenate.</p> required <code>axis</code> <code>int</code> <p>The axis along which to concatenate (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>DimArray</code> <p>Concatenated DimArray with the same unit as the first input array.</p> <p>Raises:</p> Type Description <code>DimensionError</code> <p>If arrays have incompatible dimensions.</p> <code>ValueError</code> <p>If arrays sequence is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = DimArray([1.0, 2.0], units.m)\n&gt;&gt;&gt; b = DimArray([3.0, 4.0], units.m)\n&gt;&gt;&gt; concatenate([a, b])\nDimArray([1. 2. 3. 4.], unit='m')\n</code></pre>"},{"location":"api/functions/#stack","title":"stack","text":"<p>Stack arrays along a new axis.</p> <pre><code>from dimtensor import DimArray, units, stack\n\na = DimArray([1, 2], units.m)\nb = DimArray([3, 4], units.m)\nresult = stack([a, b])  # [[1 2] [3 4]] m\n</code></pre>"},{"location":"api/functions/#dimtensor.stack","title":"<code>stack(arrays: Sequence[DimArray], axis: int = 0) -&gt; DimArray</code>","text":"<p>Stack a sequence of DimArrays along a new axis.</p> <p>All arrays must have the same unit dimension. Arrays with compatible units (e.g., km and m) will be converted to the first array's unit.</p> <p>If any arrays have uncertainty, the uncertainties are stacked. Arrays without uncertainty are treated as having zero uncertainty.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>Sequence[DimArray]</code> <p>Sequence of DimArrays to stack.</p> required <code>axis</code> <code>int</code> <p>The axis along which to stack (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>DimArray</code> <p>Stacked DimArray with the same unit as the first input array.</p> <p>Raises:</p> Type Description <code>DimensionError</code> <p>If arrays have incompatible dimensions.</p> <code>ValueError</code> <p>If arrays sequence is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = DimArray([1.0, 2.0], units.m)\n&gt;&gt;&gt; b = DimArray([3.0, 4.0], units.m)\n&gt;&gt;&gt; stack([a, b])\nDimArray([[1. 2.] [3. 4.]], unit='m')\n</code></pre>"},{"location":"api/functions/#split","title":"split","text":"<p>Split an array into sub-arrays.</p> <pre><code>from dimtensor import DimArray, units, split\n\narr = DimArray([1, 2, 3, 4], units.m)\nparts = split(arr, 2)  # [[1 2] m, [3 4] m]\n</code></pre>"},{"location":"api/functions/#dimtensor.split","title":"<code>split(array: DimArray, indices_or_sections: int | Sequence[int], axis: int = 0) -&gt; list[DimArray]</code>","text":"<p>Split a DimArray into sub-arrays.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>DimArray</code> <p>The DimArray to split.</p> required <code>indices_or_sections</code> <code>int | Sequence[int]</code> <p>If an integer N, split into N equal parts. If a sequence of integers, split at those indices.</p> required <code>axis</code> <code>int</code> <p>The axis along which to split (default: 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>list[DimArray]</code> <p>List of DimArrays, all with the same unit and uncertainty as the input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arr = DimArray([1.0, 2.0, 3.0, 4.0], units.m)\n&gt;&gt;&gt; parts = split(arr, 2)\n&gt;&gt;&gt; len(parts)\n2\n</code></pre>"},{"location":"api/functions/#linear-algebra","title":"Linear Algebra","text":""},{"location":"api/functions/#dot","title":"dot","text":"<p>Dot product of two arrays. Dimensions multiply.</p> <pre><code>from dimtensor import DimArray, units, dot\n\n# Work = Force . Displacement\nforce = DimArray([10, 0, 0], units.N)\ndisplacement = DimArray([5, 0, 0], units.m)\nwork = dot(force, displacement)  # [50] J\n</code></pre>"},{"location":"api/functions/#dimtensor.dot","title":"<code>dot(a: DimArray, b: DimArray) -&gt; DimArray</code>","text":"<p>Dot product of two DimArrays.</p> <p>Dimensions multiply: if a has dimension D1 and b has dimension D2, the result has dimension D1 * D2.</p> <p>Note: Uncertainty propagation through dot product is complex and not implemented. The result will have no uncertainty information.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>DimArray</code> <p>First array.</p> required <code>b</code> <code>DimArray</code> <p>Second array.</p> required <p>Returns:</p> Type Description <code>DimArray</code> <p>Dot product with multiplied dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; length = DimArray([1.0, 2.0, 3.0], units.m)\n&gt;&gt;&gt; force = DimArray([4.0, 5.0, 6.0], units.N)\n&gt;&gt;&gt; work = dot(length, force)  # Result has dimension of energy (J)\n</code></pre>"},{"location":"api/functions/#matmul","title":"matmul","text":"<p>Matrix multiplication. Dimensions multiply.</p> <pre><code>from dimtensor import DimArray, units, matmul\n\nA = DimArray([[1, 2], [3, 4]], units.m)\nB = DimArray([[5, 6], [7, 8]], units.s)\nC = matmul(A, B)  # Result has unit m*s\n</code></pre>"},{"location":"api/functions/#dimtensor.matmul","title":"<code>matmul(a: DimArray, b: DimArray) -&gt; DimArray</code>","text":"<p>Matrix multiplication of two DimArrays.</p> <p>Dimensions multiply: if a has dimension D1 and b has dimension D2, the result has dimension D1 * D2.</p> <p>Note: Uncertainty propagation through matrix multiplication is complex and not implemented. The result will have no uncertainty information.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>DimArray</code> <p>First array (must be at least 1D).</p> required <code>b</code> <code>DimArray</code> <p>Second array (must be at least 1D).</p> required <p>Returns:</p> Type Description <code>DimArray</code> <p>Matrix product with multiplied dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; A = DimArray([[1, 2], [3, 4]], units.m)\n&gt;&gt;&gt; B = DimArray([[5, 6], [7, 8]], units.s)\n&gt;&gt;&gt; C = matmul(A, B)  # Result has dimension m*s\n</code></pre>"},{"location":"api/functions/#norm","title":"norm","text":"<p>Compute the norm of an array. Preserves the original unit.</p> <pre><code>from dimtensor import DimArray, units, norm\n\nvelocity = DimArray([3, 4], units.m / units.s)\nspeed = norm(velocity)  # [5] m/s\n</code></pre>"},{"location":"api/functions/#dimtensor.norm","title":"<code>norm(array: DimArray, ord: float | None = None, axis: int | None = None, keepdims: bool = False) -&gt; DimArray</code>","text":"<p>Compute the norm of a DimArray.</p> <p>The result preserves the original unit (norm of meters is meters).</p> <p>Note: Uncertainty propagation through norm is complex and not implemented. The result will have no uncertainty information.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>DimArray</code> <p>Input array.</p> required <code>ord</code> <code>float | None</code> <p>Order of the norm (see numpy.linalg.norm). None = 2-norm for vectors, Frobenius for matrices. Other values: 1, 2, inf, -inf, etc.</p> <code>None</code> <code>axis</code> <code>int | None</code> <p>Axis along which to compute the norm. If None, computes norm of flattened array.</p> <code>None</code> <code>keepdims</code> <code>bool</code> <p>If True, the reduced axes are kept with size 1.</p> <code>False</code> <p>Returns:</p> Type Description <code>DimArray</code> <p>Norm with the same unit as the input array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = DimArray([3.0, 4.0], units.m)\n&gt;&gt;&gt; norm(v)  # 5.0 m\nDimArray([5.], unit='m')\n</code></pre>"},{"location":"api/functions/#exceptions","title":"Exceptions","text":""},{"location":"api/functions/#dimensionerror","title":"DimensionError","text":"<p>Raised when dimensions are incompatible for an operation.</p> <pre><code>from dimtensor import DimArray, DimensionError, units\n\ntry:\n    a = DimArray([1], units.m)\n    b = DimArray([1], units.s)\n    a + b  # Cannot add m to s\nexcept DimensionError as e:\n    print(e)  # \"Cannot add quantities with dimensions L and T\"\n</code></pre>"},{"location":"api/functions/#dimtensor.DimensionError","title":"<code>DimensionError</code>","text":"<p>               Bases: <code>DimTensorError</code></p> <p>Raised when dimensions are incompatible for an operation.</p>"},{"location":"api/functions/#dimtensor.DimensionError.incompatible","title":"<code>incompatible(left: Dimension, right: Dimension, operation: str) -&gt; DimensionError</code>  <code>classmethod</code>","text":"<p>Create an error for incompatible dimensions.</p>"},{"location":"api/functions/#unitconversionerror","title":"UnitConversionError","text":"<p>Raised when unit conversion is not possible.</p> <pre><code>from dimtensor import DimArray, UnitConversionError, units\n\ntry:\n    distance = DimArray([1], units.m)\n    distance.to(units.s)  # Cannot convert m to s\nexcept UnitConversionError as e:\n    print(e)\n</code></pre>"},{"location":"api/functions/#dimtensor.UnitConversionError","title":"<code>UnitConversionError</code>","text":"<p>               Bases: <code>DimTensorError</code></p> <p>Raised when unit conversion is not possible.</p>"},{"location":"api/functions/#dimtensor.UnitConversionError.incompatible","title":"<code>incompatible(from_unit: str, to_unit: str) -&gt; UnitConversionError</code>  <code>classmethod</code>","text":"<p>Create an error for incompatible unit conversion.</p>"},{"location":"api/units/","title":"Units","text":"<p>Physical units for dimensional analysis.</p>"},{"location":"api/units/#usage","title":"Usage","text":"<pre><code>from dimtensor import units\n\n# Access units\nunits.m      # meter\nunits.kg     # kilogram\nunits.s      # second\n\n# Create compound units\nvelocity = units.m / units.s\nacceleration = units.m / units.s**2\nforce = units.kg * units.m / units.s**2  # Same as units.N\n</code></pre>"},{"location":"api/units/#si-base-units","title":"SI Base Units","text":"Attribute Symbol Dimension <code>units.m</code> m Length <code>units.kg</code> kg Mass <code>units.s</code> s Time <code>units.A</code> A Electric current <code>units.K</code> K Temperature <code>units.mol</code> mol Amount of substance <code>units.cd</code> cd Luminous intensity"},{"location":"api/units/#si-derived-units","title":"SI Derived Units","text":"Attribute Symbol Equivalent <code>units.N</code> N kg*m/s^2 <code>units.J</code> J kg*m^2/s^2 <code>units.W</code> W kg*m^2/s^3 <code>units.Pa</code> Pa kg/(m*s^2) <code>units.Hz</code> Hz 1/s <code>units.C</code> C A*s <code>units.V</code> V kgm^2/(As^3) <code>units.F</code> F A^2s^4/(kgm^2) <code>units.ohm</code> ohm kgm^2/(A^2s^3)"},{"location":"api/units/#length-units","title":"Length Units","text":"Attribute Symbol SI Value <code>units.m</code> m 1 m <code>units.km</code> km 1000 m <code>units.cm</code> cm 0.01 m <code>units.mm</code> mm 0.001 m <code>units.um</code> um 1e-6 m <code>units.nm</code> nm 1e-9 m <code>units.mile</code> mi 1609.344 m <code>units.ft</code> ft 0.3048 m <code>units.inch</code> in 0.0254 m"},{"location":"api/units/#time-units","title":"Time Units","text":"Attribute Symbol SI Value <code>units.s</code> s 1 s <code>units.ms</code> ms 0.001 s <code>units.us</code> us 1e-6 s <code>units.ns</code> ns 1e-9 s <code>units.minute</code> min 60 s <code>units.hour</code> h 3600 s <code>units.day</code> d 86400 s"},{"location":"api/units/#energy-units","title":"Energy Units","text":"Attribute Symbol SI Value <code>units.J</code> J 1 J <code>units.kJ</code> kJ 1000 J <code>units.eV</code> eV 1.602e-19 J <code>units.cal</code> cal 4.184 J <code>units.kcal</code> kcal 4184 J"},{"location":"api/units/#pressure-units","title":"Pressure Units","text":"Attribute Symbol SI Value <code>units.Pa</code> Pa 1 Pa <code>units.kPa</code> kPa 1000 Pa <code>units.bar</code> bar 1e5 Pa <code>units.atm</code> atm 101325 Pa"},{"location":"api/units/#angle-units","title":"Angle Units","text":"Attribute Symbol Note <code>units.rad</code> rad Dimensionless <code>units.deg</code> deg pi/180 rad"},{"location":"api/units/#api-reference","title":"API Reference","text":""},{"location":"api/units/#dimtensor.Unit","title":"<code>Unit</code>  <code>dataclass</code>","text":"<p>Represents a physical unit.</p> <p>A unit combines a dimension with a scale factor. The scale factor represents how many SI base units equal one of this unit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; meter = Unit(\"m\", Dimension(length=1), 1.0)\n&gt;&gt;&gt; kilometer = Unit(\"km\", Dimension(length=1), 1000.0)\n&gt;&gt;&gt; # 1 km = 1000 m, so scale = 1000\n</code></pre>"},{"location":"api/units/#dimtensor.Unit.symbol","title":"<code>symbol: str</code>  <code>instance-attribute</code>","text":""},{"location":"api/units/#dimtensor.Unit.dimension","title":"<code>dimension: Dimension</code>  <code>instance-attribute</code>","text":""},{"location":"api/units/#dimtensor.Unit.scale","title":"<code>scale: float</code>  <code>instance-attribute</code>","text":""},{"location":"api/units/#dimtensor.Dimension","title":"<code>Dimension</code>  <code>dataclass</code>","text":"<p>Represents the physical dimension of a quantity.</p> <p>A dimension is represented as a tuple of rational exponents for each of the 7 SI base dimensions. For example: - Velocity has dimension L\u00b9T\u207b\u00b9 (length=1, time=-1) - Force has dimension M\u00b9L\u00b9T\u207b\u00b2 (mass=1, length=1, time=-2)</p> <p>Dimensions support algebraic operations: - Multiplication: adds exponents - Division: subtracts exponents - Power: multiplies exponents by the power</p>"},{"location":"api/units/#dimtensor.Dimension.length","title":"<code>length: Fraction</code>  <code>property</code>","text":"<p>Exponent of length dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.mass","title":"<code>mass: Fraction</code>  <code>property</code>","text":"<p>Exponent of mass dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.time","title":"<code>time: Fraction</code>  <code>property</code>","text":"<p>Exponent of time dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.current","title":"<code>current: Fraction</code>  <code>property</code>","text":"<p>Exponent of electric current dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.temperature","title":"<code>temperature: Fraction</code>  <code>property</code>","text":"<p>Exponent of temperature dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.amount","title":"<code>amount: Fraction</code>  <code>property</code>","text":"<p>Exponent of amount of substance dimension.</p>"},{"location":"api/units/#dimtensor.Dimension.luminosity","title":"<code>luminosity: Fraction</code>  <code>property</code>","text":"<p>Exponent of luminous intensity dimension.</p>"},{"location":"comparisons/","title":"Python Units Library Comparison","text":"<p>Choosing the right units library depends on your use case. This section compares dimtensor with other popular Python unit libraries.</p>"},{"location":"comparisons/#quick-comparison","title":"Quick Comparison","text":"Feature dimtensor Pint Astropy unyt NumPy support Full Full Full Full PyTorch support Native Limited None None JAX support Native None None None Autograd Yes No No No GPU support Yes No No Yes Uncertainty Built-in Extension Separate No Physical constants CODATA 2022 Via scipy Built-in yt constants I/O formats 6+ Limited FITS yt native"},{"location":"comparisons/#when-to-choose-dimtensor","title":"When to Choose dimtensor","text":"<ul> <li>Machine learning - Native PyTorch/JAX with autograd</li> <li>GPU computing - CUDA/MPS support with units</li> <li>Scientific simulations - Uncertainty propagation built-in</li> <li>Multi-framework - Same API across NumPy, PyTorch, JAX</li> </ul>"},{"location":"comparisons/#detailed-comparisons","title":"Detailed Comparisons","text":"<ul> <li>dimtensor vs Pint - The most popular Python units library</li> <li>dimtensor vs Astropy - Astronomy-focused units</li> <li>dimtensor vs unyt - yt project's units library</li> <li>Feature Matrix - Comprehensive feature comparison</li> </ul>"},{"location":"comparisons/feature-matrix/","title":"Python Units Library Feature Matrix","text":"<p>A comprehensive comparison of Python units libraries to help you choose the right tool for your project.</p>"},{"location":"comparisons/feature-matrix/#overview","title":"Overview","text":"Library Primary Focus Best For dimtensor Physics + ML PyTorch/JAX workflows, GPU computing Pint General purpose Flexible unit systems, data analysis Astropy Astronomy Astronomical calculations, FITS files unyt Astrophysics yt project, large simulations"},{"location":"comparisons/feature-matrix/#core-features","title":"Core Features","text":"Feature dimtensor Pint Astropy unyt NumPy arrays Yes Yes Yes Yes SI units Yes Yes Yes Yes CGS units Yes Yes Yes Yes Imperial units Yes Yes Yes Yes Custom units Limited Extensive Limited Limited Unit simplification Auto Auto Auto Auto"},{"location":"comparisons/feature-matrix/#framework-integration","title":"Framework Integration","text":"Feature dimtensor Pint Astropy unyt PyTorch native Yes No No No JAX native Yes No No No Autograd support Yes No No No GPU (CUDA) Yes No No No GPU (MPS/Apple) Yes No No No Dask arrays No Yes No Yes Sparse arrays No Yes No No"},{"location":"comparisons/feature-matrix/#scientific-computing","title":"Scientific Computing","text":"Feature dimtensor Pint Astropy unyt Physical constants CODATA 2022 scipy.constants Built-in yt constants Uncertainty propagation Built-in Extension Separate No Temperature handling Yes Yes Yes Yes Logarithmic units (dB) No Yes Yes No Equivalencies Basic Basic Advanced Basic"},{"location":"comparisons/feature-matrix/#domain-specific-units","title":"Domain-Specific Units","text":"Domain dimtensor Pint Astropy unyt Astronomy Module Basic Comprehensive Comprehensive Chemistry Module Basic No No Engineering Module Basic No No Cosmology No No Yes Yes"},{"location":"comparisons/feature-matrix/#io-support","title":"I/O Support","text":"Format dimtensor Pint Astropy unyt JSON Yes Manual No Yes HDF5 Yes Manual Table Yes Parquet Yes No No No NetCDF Yes No No No pandas Yes pint-pandas No Limited xarray Yes pint-xarray No No FITS No No Native No VOTable No No Native No"},{"location":"comparisons/feature-matrix/#performance","title":"Performance","text":"Metric dimtensor Pint Astropy unyt Overhead vs NumPy 2-5x 2-5x 2-3x 1.5-3x Memory efficiency Good Good Good Good GPU acceleration Yes No No No JIT compilation JAX No No No"},{"location":"comparisons/feature-matrix/#documentation-community","title":"Documentation &amp; Community","text":"Metric dimtensor Pint Astropy unyt Documentation Good Excellent Excellent Good Tutorials Growing Many Many Some Stack Overflow New Active Active Moderate GitHub stars Growing ~2k ~4k (main) ~400"},{"location":"comparisons/feature-matrix/#installation-size","title":"Installation Size","text":"Library Install Size Dependencies dimtensor ~500 KB numpy Pint ~1 MB numpy Astropy ~50 MB numpy, scipy, etc. unyt ~2 MB numpy, sympy"},{"location":"comparisons/feature-matrix/#code-examples","title":"Code Examples","text":""},{"location":"comparisons/feature-matrix/#creating-arrays","title":"Creating Arrays","text":"dimtensorPintAstropyunyt <pre><code>from dimtensor import DimArray, units\narr = DimArray([1, 2, 3], units.m / units.s)\n</code></pre> <pre><code>import pint\nureg = pint.UnitRegistry()\narr = [1, 2, 3] * ureg.meter / ureg.second\n</code></pre> <pre><code>from astropy import units as u\narr = [1, 2, 3] * u.m / u.s\n</code></pre> <pre><code>from unyt import unyt_array\narr = unyt_array([1, 2, 3], 'm/s')\n</code></pre>"},{"location":"comparisons/feature-matrix/#unit-conversion","title":"Unit Conversion","text":"dimtensorPintAstropyunyt <pre><code>distance = DimArray([1000], units.m)\nin_km = distance.to(units.km)  # 1 km\n</code></pre> <pre><code>distance = 1000 * ureg.meter\nin_km = distance.to('km')  # 1 km\n</code></pre> <pre><code>distance = 1000 * u.m\nin_km = distance.to(u.km)  # 1 km\n</code></pre> <pre><code>distance = unyt_array([1000], 'm')\nin_km = distance.to('km')  # 1 km\n</code></pre>"},{"location":"comparisons/feature-matrix/#decision-guide","title":"Decision Guide","text":""},{"location":"comparisons/feature-matrix/#choose-dimtensor-if","title":"Choose dimtensor if:","text":"<ul> <li>You need PyTorch or JAX integration</li> <li>You're doing machine learning with physical units</li> <li>You need GPU acceleration</li> <li>You want built-in uncertainty propagation</li> <li>You need multiple I/O formats</li> </ul>"},{"location":"comparisons/feature-matrix/#choose-pint-if","title":"Choose Pint if:","text":"<ul> <li>You need maximum flexibility in unit definitions</li> <li>You're doing pure data analysis (no ML)</li> <li>You have complex custom unit systems</li> <li>You need pandas integration</li> </ul>"},{"location":"comparisons/feature-matrix/#choose-astropy-if","title":"Choose Astropy if:","text":"<ul> <li>You're doing astronomy/astrophysics</li> <li>You need spectral equivalencies</li> <li>You work with FITS files</li> <li>You use other Astropy tools</li> </ul>"},{"location":"comparisons/feature-matrix/#choose-unyt-if","title":"Choose unyt if:","text":"<ul> <li>You use the yt project</li> <li>You're doing astrophysical simulations</li> <li>You need cosmological units</li> <li>You work with very large datasets (Dask)</li> </ul>"},{"location":"comparisons/feature-matrix/#summary","title":"Summary","text":"<p>For machine learning and GPU computing: dimtensor</p> <p>For general purpose flexibility: Pint</p> <p>For astronomy: Astropy</p> <p>For yt/simulations: unyt</p>"},{"location":"comparisons/vs-astropy/","title":"dimtensor vs Astropy Units","text":"<p>Astropy provides a comprehensive units package designed for astronomy. This page compares it with dimtensor.</p>"},{"location":"comparisons/vs-astropy/#tldr","title":"TL;DR","text":"Feature dimtensor Astropy Focus General physics + ML Astronomy PyTorch support Native None JAX support Native None Astronomy units Domain module Comprehensive Equivalencies Basic Advanced (spectral, etc.) FITS I/O No Native Uncertainty Built-in Separate NDData"},{"location":"comparisons/vs-astropy/#when-to-choose-dimtensor","title":"When to Choose dimtensor","text":"<p>Choose dimtensor if you need:</p> <ul> <li>Machine learning with units (PyTorch, JAX)</li> <li>GPU acceleration</li> <li>Built-in uncertainty propagation</li> <li>Multi-framework support (NumPy + PyTorch + JAX)</li> <li>General physics beyond astronomy</li> </ul> <pre><code># dimtensor: ML with astronomy units\nfrom dimtensor.torch import DimTensor\nfrom dimtensor.domains.astronomy import solar_mass, parsec\nimport torch\n\nmass = DimTensor(torch.tensor([1.0], requires_grad=True), solar_mass)\n# Use in neural network training...\n</code></pre>"},{"location":"comparisons/vs-astropy/#when-to-choose-astropy","title":"When to Choose Astropy","text":"<p>Choose Astropy if you need:</p> <ul> <li>Comprehensive astronomy unit system</li> <li>Spectral equivalencies (wavelength/frequency/energy)</li> <li>FITS file I/O with units</li> <li>Coordinate transformations</li> <li>Integration with other Astropy tools</li> </ul> <pre><code># Astropy: Spectral equivalencies\nfrom astropy import units as u\n\nwavelength = 500 * u.nm\nfrequency = wavelength.to(u.Hz, equivalencies=u.spectral())\nenergy = wavelength.to(u.eV, equivalencies=u.spectral())\n</code></pre>"},{"location":"comparisons/vs-astropy/#feature-comparison","title":"Feature Comparison","text":""},{"location":"comparisons/vs-astropy/#unit-systems","title":"Unit Systems","text":"dimtensorAstropy <pre><code>from dimtensor import DimArray, units\nfrom dimtensor.domains.astronomy import parsec, AU, solar_mass, light_year\n\n# Core astronomy units available\ndistance = DimArray([4.24], light_year)\ndistance_pc = distance.to(parsec)\n</code></pre> <pre><code>from astropy import units as u\n\n# Extensive astronomy unit system\ndistance = 4.24 * u.lyr\ndistance_pc = distance.to(u.pc)\n\n# Specialized astronomy units\nflux = 1e-23 * u.erg / u.s / u.cm**2 / u.Hz  # Jansky-like\nmagnitude = 5 * u.mag\n</code></pre>"},{"location":"comparisons/vs-astropy/#equivalencies","title":"Equivalencies","text":"<p>Astropy excels at equivalencies (conversions between physically related but dimensionally different quantities):</p> dimtensorAstropy <pre><code># dimtensor focuses on dimensional correctness\n# Explicit conversions required\nfrom dimtensor import DimArray, units\nfrom dimtensor import constants\n\nwavelength = DimArray([500e-9], units.m)  # 500 nm\nfrequency = constants.c / wavelength  # Manual conversion\n</code></pre> <pre><code>from astropy import units as u\n\n# Automatic equivalencies\nwavelength = 500 * u.nm\n\n# Convert between wavelength, frequency, and energy\nfreq = wavelength.to(u.Hz, equivalencies=u.spectral())\nenergy = wavelength.to(u.eV, equivalencies=u.spectral())\n\n# Temperature equivalencies\ntemp = 5000 * u.K\nwavelength_peak = temp.to(u.um, equivalencies=u.temperature_energy())\n</code></pre>"},{"location":"comparisons/vs-astropy/#machine-learning","title":"Machine Learning","text":"dimtensorAstropy <pre><code>import jax\nfrom dimtensor.jax import DimArray\nfrom dimtensor.domains.astronomy import solar_mass\n\n@jax.jit\ndef gravitational_energy(m1, m2, r):\n    from dimtensor import constants\n    return -constants.G * m1 * m2 / r\n\n# JIT-compiled, units preserved throughout\n</code></pre> <pre><code># Astropy units don't work with JAX or PyTorch\n# Must strip units before ML operations\nfrom astropy import units as u\n\nmass = 1.0 * u.solMass\nmass_value = mass.to(u.kg).value  # Strip units for ML\n</code></pre>"},{"location":"comparisons/vs-astropy/#io-support","title":"I/O Support","text":"Format dimtensor Astropy JSON Yes No HDF5 Yes Via Astropy Table Parquet Yes No NetCDF Yes No FITS No Native VOTable No Native"},{"location":"comparisons/vs-astropy/#uncertainty-handling","title":"Uncertainty Handling","text":"dimtensorAstropy <pre><code>from dimtensor import DimArray\nfrom dimtensor.domains.astronomy import parsec\n\n# Built-in uncertainty\ndistance = DimArray([10.0], parsec, uncertainty=[0.5])\nluminosity = distance ** 2  # Uncertainty propagates\n</code></pre> <pre><code>from astropy import units as u\nfrom astropy.nddata import NDDataArray, StdDevUncertainty\n\n# Separate uncertainty container\ndata = NDDataArray([10.0] * u.pc,\n                   uncertainty=StdDevUncertainty([0.5] * u.pc))\n</code></pre>"},{"location":"comparisons/vs-astropy/#migration-from-astropy","title":"Migration from Astropy","text":"<p>If you're adding ML to astronomy code:</p> <pre><code># Astropy code\nfrom astropy import units as u\nfrom astropy import constants as const\n\nmass = 1.0 * u.solMass\nvelocity = 200 * u.km / u.s\nkinetic_energy = 0.5 * mass * velocity**2\n\n# dimtensor equivalent (for ML compatibility)\nfrom dimtensor import DimArray\nfrom dimtensor.domains.astronomy import solar_mass\nfrom dimtensor import units\n\nmass = DimArray([1.0], solar_mass)\nvelocity = DimArray([200], units.km / units.s)\nkinetic_energy = 0.5 * mass * velocity**2\n# Now can use with PyTorch/JAX\n</code></pre>"},{"location":"comparisons/vs-astropy/#using-both-together","title":"Using Both Together","text":"<p>For astronomy projects needing ML, consider using both:</p> <pre><code>from astropy import units as u\nfrom dimtensor import DimArray, units as dt_units\nfrom dimtensor.torch import DimTensor\nimport torch\n\n# Load data with Astropy (FITS, coordinates, etc.)\nfrom astropy.io import fits\ndata = fits.getdata('observations.fits')\nastropy_flux = data * u.Jy\n\n# Convert to dimtensor for ML\nflux_values = astropy_flux.to(u.W / u.m**2 / u.Hz).value\nflux = DimTensor(torch.tensor(flux_values), dt_units.W / dt_units.m**2 / dt_units.Hz)\n\n# Train your model with units preserved...\n</code></pre>"},{"location":"comparisons/vs-astropy/#conclusion","title":"Conclusion","text":"<ul> <li>Use dimtensor for ML workflows, GPU computing, or general physics</li> <li>Use Astropy for astronomy-specific workflows, FITS files, or coordinate transformations</li> <li>Use both when you need Astropy's astronomy features plus ML capabilities</li> </ul>"},{"location":"comparisons/vs-pint/","title":"dimtensor vs Pint","text":"<p>Pint is the most popular Python library for physical units. This page compares it with dimtensor to help you choose the right tool.</p>"},{"location":"comparisons/vs-pint/#tldr","title":"TL;DR","text":"Feature dimtensor Pint PyTorch integration Native autograd Limited wrapping JAX integration Native pytree None GPU support CUDA, MPS No Uncertainty Built-in Via <code>pint[uncertainties]</code> Unit definitions SI + domains Highly customizable Performance 2-5x NumPy Similar"},{"location":"comparisons/vs-pint/#when-to-choose-dimtensor","title":"When to Choose dimtensor","text":"<p>Choose dimtensor if you need:</p> <ul> <li>Machine learning with PyTorch or JAX</li> <li>Automatic differentiation through unit-aware operations</li> <li>GPU acceleration (CUDA or Apple Silicon)</li> <li>Built-in uncertainty propagation</li> <li>Multiple I/O formats (HDF5, NetCDF, Parquet)</li> </ul> <pre><code># dimtensor: Native PyTorch autograd\nfrom dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\nv = DimTensor(torch.tensor([1.0], requires_grad=True), units.m / units.s)\nt = DimTensor(torch.tensor([2.0]), units.s)\nd = v * t\nd.backward()  # Gradients flow through\nprint(v.grad)  # Works!\n</code></pre>"},{"location":"comparisons/vs-pint/#when-to-choose-pint","title":"When to Choose Pint","text":"<p>Choose Pint if you need:</p> <ul> <li>Complex custom unit systems</li> <li>Non-SI units with unusual conversions</li> <li>Mature ecosystem with extensive documentation</li> <li>Pandas integration via <code>pint-pandas</code></li> <li>Maximum flexibility in unit definitions</li> </ul> <pre><code># Pint: Custom unit systems\nimport pint\nureg = pint.UnitRegistry()\n\n# Define custom units\nureg.define('smoot = 1.7018 * meter')\ndistance = 100 * ureg.smoot\nprint(distance.to('meter'))  # 170.18 meter\n</code></pre>"},{"location":"comparisons/vs-pint/#feature-comparison","title":"Feature Comparison","text":""},{"location":"comparisons/vs-pint/#numpy-integration","title":"NumPy Integration","text":"<p>Both libraries wrap NumPy arrays effectively:</p> dimtensorPint <pre><code>from dimtensor import DimArray, units\nimport numpy as np\n\narr = DimArray(np.array([1, 2, 3]), units.m)\nresult = np.sqrt(arr)  # Returns DimArray with m^0.5\n</code></pre> <pre><code>import pint\nimport numpy as np\n\nureg = pint.UnitRegistry()\narr = np.array([1, 2, 3]) * ureg.meter\nresult = np.sqrt(arr)  # Returns Quantity with m^0.5\n</code></pre>"},{"location":"comparisons/vs-pint/#machine-learning","title":"Machine Learning","text":"<p>dimtensor provides native PyTorch and JAX support. Pint requires workarounds:</p> dimtensorPint <pre><code>import jax\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n@jax.jit\ndef kinetic_energy(m, v):\n    return 0.5 * m * v**2\n\nm = DimArray([1.0], units.kg)\nv = DimArray([10.0], units.m / units.s)\nE = kinetic_energy(m, v)  # JIT works, units preserved\n</code></pre> <pre><code># Pint doesn't support JAX\n# For PyTorch, you must strip units before operations\n# and manually track dimensions\n</code></pre>"},{"location":"comparisons/vs-pint/#uncertainty-propagation","title":"Uncertainty Propagation","text":"dimtensorPint <pre><code>from dimtensor import DimArray, units\n\n# Built-in uncertainty support\nlength = DimArray([10.0], units.m, uncertainty=[0.1])\narea = length ** 2  # Uncertainty propagates automatically\n</code></pre> <pre><code>import pint\nfrom uncertainties import ufloat\n\nureg = pint.UnitRegistry()\n# Requires uncertainties package\nlength = ufloat(10.0, 0.1) * ureg.meter\narea = length ** 2\n</code></pre>"},{"location":"comparisons/vs-pint/#io-support","title":"I/O Support","text":"Format dimtensor Pint JSON Yes Manual HDF5 Yes Manual Parquet Yes No NetCDF Yes No pandas Yes pint-pandas xarray Yes pint-xarray"},{"location":"comparisons/vs-pint/#migration-from-pint","title":"Migration from Pint","text":"<p>If you're moving from Pint to dimtensor:</p> <pre><code># Pint code\nimport pint\nureg = pint.UnitRegistry()\nvelocity = 10 * ureg.meter / ureg.second\ntime = 5 * ureg.second\ndistance = velocity * time\n\n# dimtensor equivalent\nfrom dimtensor import DimArray, units\nvelocity = DimArray([10], units.m / units.s)\ntime = DimArray([5], units.s)\ndistance = velocity * time\n</code></pre> <p>Key differences: - dimtensor uses <code>DimArray()</code> constructor instead of multiplication - Units accessed via <code>units.m</code> instead of <code>ureg.meter</code> - Both use <code>/</code> and <code>**</code> for compound units</p>"},{"location":"comparisons/vs-pint/#performance","title":"Performance","text":"<p>Both libraries have similar overhead for NumPy operations (2-5x raw NumPy). dimtensor's advantage appears in:</p> <ul> <li>GPU operations - Native CUDA support</li> <li>Autograd - No unit stripping/reattaching overhead</li> <li>Batch operations - Better optimization for large arrays</li> </ul>"},{"location":"comparisons/vs-pint/#conclusion","title":"Conclusion","text":"<ul> <li>Use dimtensor for ML, GPU computing, or projects needing PyTorch/JAX</li> <li>Use Pint for complex unit systems, maximum flexibility, or pure data analysis</li> </ul> <p>Both are excellent libraries. The choice depends on your specific requirements.</p>"},{"location":"comparisons/vs-unyt/","title":"dimtensor vs unyt","text":"<p>unyt is the units library from the yt project, designed for astrophysical simulations. This page compares it with dimtensor.</p>"},{"location":"comparisons/vs-unyt/#tldr","title":"TL;DR","text":"Feature dimtensor unyt PyTorch support Native None JAX support Native None GPU support CUDA, MPS Dask arrays Uncertainty Built-in No yt integration No Native Performance 2-5x NumPy Optimized Cosmology units No Yes"},{"location":"comparisons/vs-unyt/#when-to-choose-dimtensor","title":"When to Choose dimtensor","text":"<p>Choose dimtensor if you need:</p> <ul> <li>Machine learning with PyTorch or JAX</li> <li>GPU acceleration with unit tracking</li> <li>Built-in uncertainty propagation</li> <li>Multiple I/O formats (HDF5, NetCDF, Parquet)</li> </ul> <pre><code># dimtensor: PyTorch with autograd\nfrom dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\nv = DimTensor(torch.tensor([1.0, 2.0], requires_grad=True), units.m / units.s)\nenergy = 0.5 * v ** 2\nenergy.sum().backward()  # Gradients work\n</code></pre>"},{"location":"comparisons/vs-unyt/#when-to-choose-unyt","title":"When to Choose unyt","text":"<p>Choose unyt if you need:</p> <ul> <li>Integration with yt for astrophysical visualizations</li> <li>Cosmological unit conversions</li> <li>Optimized performance for large simulations</li> <li>Dask array support for out-of-core computation</li> </ul> <pre><code># unyt: Cosmological units\nfrom unyt import unyt_array\nfrom unyt.unit_systems import cgs_unit_system\n\n# Comoving coordinates\ndistance = unyt_array([100], 'Mpc/h')\n\n# yt integration\nimport yt\nds = yt.load(\"simulation.hdf5\")\n# Units handled automatically\n</code></pre>"},{"location":"comparisons/vs-unyt/#feature-comparison","title":"Feature Comparison","text":""},{"location":"comparisons/vs-unyt/#basic-usage","title":"Basic Usage","text":"dimtensorunyt <pre><code>from dimtensor import DimArray, units\n\nvelocity = DimArray([10, 20, 30], units.m / units.s)\ntime = DimArray([1, 2, 3], units.s)\ndistance = velocity * time\n</code></pre> <pre><code>from unyt import unyt_array\n\nvelocity = unyt_array([10, 20, 30], 'm/s')\ntime = unyt_array([1, 2, 3], 's')\ndistance = velocity * time\n</code></pre>"},{"location":"comparisons/vs-unyt/#machine-learning","title":"Machine Learning","text":"dimtensorunyt <pre><code>import jax\nimport jax.numpy as jnp\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n@jax.jit\ndef simulate(mass, velocity):\n    return 0.5 * mass * velocity**2\n\nm = DimArray(jnp.array([1.0, 2.0]), units.kg)\nv = DimArray(jnp.array([10.0, 20.0]), units.m / units.s)\nE = simulate(m, v)  # JIT works with units\n</code></pre> <pre><code># unyt doesn't support JAX or PyTorch\n# Must extract values for ML frameworks\nfrom unyt import unyt_array\n\nmass = unyt_array([1.0, 2.0], 'kg')\nmass_values = mass.v  # Extract values for ML\n</code></pre>"},{"location":"comparisons/vs-unyt/#gpu-support","title":"GPU Support","text":"dimtensorunyt <pre><code>from dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\n# Native CUDA support\narr = DimTensor(torch.randn(1000, 1000), units.m)\narr_gpu = arr.cuda()  # Units preserved on GPU\nresult = arr_gpu @ arr_gpu.T  # GPU computation with units\n</code></pre> <pre><code># unyt uses Dask for distributed computing\n# No direct GPU support\nfrom unyt import unyt_array\nimport dask.array as da\n\n# Dask for out-of-core computation\ndata = da.from_array(large_array, chunks=(1000, 1000))\n# Limited unit support with Dask\n</code></pre>"},{"location":"comparisons/vs-unyt/#uncertainty-propagation","title":"Uncertainty Propagation","text":"dimtensorunyt <pre><code>from dimtensor import DimArray, units\n\n# Built-in uncertainty\nmeasurement = DimArray([10.0], units.m, uncertainty=[0.1])\narea = measurement ** 2  # Uncertainty propagates\nprint(area)  # 100 +/- 2.0 m^2\n</code></pre> <pre><code># unyt doesn't have built-in uncertainty\n# Must track manually or use separate library\nfrom unyt import unyt_array\nimport uncertainties\n\n# Manual tracking required\n</code></pre>"},{"location":"comparisons/vs-unyt/#io-support","title":"I/O Support","text":"Format dimtensor unyt JSON Yes Yes HDF5 Yes Yes (yt native) Parquet Yes No NetCDF Yes No pandas Yes Limited yt datasets No Native"},{"location":"comparisons/vs-unyt/#performance-comparison","title":"Performance Comparison","text":"<p>Both libraries prioritize performance for scientific computing:</p> Operation dimtensor unyt Array creation ~2x NumPy ~1.5x NumPy Arithmetic ~2-5x NumPy ~2-3x NumPy Unit conversion Fast Fast GPU operations Native N/A <p>unyt is slightly more optimized for pure NumPy operations, while dimtensor provides GPU acceleration.</p>"},{"location":"comparisons/vs-unyt/#migration-from-unyt","title":"Migration from unyt","text":"<p>If you're adding ML to simulation code:</p> <pre><code># unyt code\nfrom unyt import unyt_array\n\nmass = unyt_array([1e10, 2e10], 'Msun')\nvelocity = unyt_array([100, 200], 'km/s')\nkinetic_energy = 0.5 * mass * velocity**2\n\n# dimtensor equivalent\nfrom dimtensor import DimArray\nfrom dimtensor.domains.astronomy import solar_mass\nfrom dimtensor import units\n\nmass = DimArray([1e10, 2e10], solar_mass)\nvelocity = DimArray([100, 200], units.km / units.s)\nkinetic_energy = 0.5 * mass * velocity**2\n# Now works with PyTorch/JAX\n</code></pre>"},{"location":"comparisons/vs-unyt/#using-both-together","title":"Using Both Together","text":"<p>For yt-based projects needing ML:</p> <pre><code>import yt\nfrom dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\n# Load simulation with yt (uses unyt internally)\nds = yt.load(\"simulation.hdf5\")\nad = ds.all_data()\n\n# Extract data for ML\ndensity_values = ad['gas', 'density'].to('g/cm**3').v\ntemperature_values = ad['gas', 'temperature'].to('K').v\n\n# Convert to dimtensor for ML pipeline\ndensity = DimTensor(\n    torch.tensor(density_values, dtype=torch.float32),\n    units.g / units.cm**3\n)\ntemperature = DimTensor(\n    torch.tensor(temperature_values, dtype=torch.float32),\n    units.K\n)\n\n# Now use in your neural network...\n</code></pre>"},{"location":"comparisons/vs-unyt/#conclusion","title":"Conclusion","text":"<ul> <li>Use dimtensor for ML workflows, GPU computing, or uncertainty propagation</li> <li>Use unyt for yt integration, cosmological simulations, or Dask-based workflows</li> <li>Use both when you need yt's analysis tools plus ML capabilities</li> </ul>"},{"location":"guide/examples/","title":"Examples","text":"<p>Real-world physics calculations with dimtensor.</p>"},{"location":"guide/examples/#mechanics","title":"Mechanics","text":""},{"location":"guide/examples/#kinematics","title":"Kinematics","text":"<pre><code>from dimtensor import DimArray, units\n\n# Initial velocity and acceleration\nv0 = DimArray([10], units.m / units.s)\na = DimArray([2], units.m / units.s**2)\nt = DimArray([5], units.s)\n\n# Final velocity: v = v0 + a*t\nv = v0 + a * t\nprint(f\"Final velocity: {v}\")  # 20.0 m/s\n\n# Distance: d = v0*t + 0.5*a*t^2\nd = v0 * t + 0.5 * a * t**2\nprint(f\"Distance: {d}\")  # 75.0 m\n</code></pre>"},{"location":"guide/examples/#force-and-energy","title":"Force and Energy","text":"<pre><code>from dimtensor import DimArray, units, dot, norm\n\n# Mass and gravity\nm = DimArray([2.0], units.kg)\ng = DimArray([9.8], units.m / units.s**2)\n\n# Weight (force)\nF = m * g\nprint(f\"Weight: {F}\")  # 19.6 N\n\n# Potential energy at height h\nh = DimArray([10.0], units.m)\nPE = m * g * h\nprint(f\"Potential energy: {PE}\")  # 196.0 J\n\n# Kinetic energy\nv = DimArray([5.0], units.m / units.s)\nKE = 0.5 * m * v**2\nprint(f\"Kinetic energy: {KE}\")  # 25.0 J\n</code></pre>"},{"location":"guide/examples/#projectile-motion","title":"Projectile Motion","text":"<pre><code>import numpy as np\nfrom dimtensor import DimArray, units, norm\n\n# Launch parameters\nv0 = DimArray([20], units.m / units.s)  # initial speed\ntheta = DimArray([45 * np.pi / 180], units.rad)  # launch angle\ng = DimArray([9.8], units.m / units.s**2)\n\n# Initial velocity components\nvx = v0 * np.cos(theta)\nvy = v0 * np.sin(theta)\n\n# Time of flight\nt_flight = 2 * vy / g\nprint(f\"Time of flight: {t_flight.to(units.s)}\")\n\n# Maximum height\nh_max = vy**2 / (2 * g)\nprint(f\"Maximum height: {h_max}\")\n\n# Range\nR = vx * t_flight\nprint(f\"Range: {R}\")\n</code></pre>"},{"location":"guide/examples/#electricity","title":"Electricity","text":""},{"location":"guide/examples/#ohms-law","title":"Ohm's Law","text":"<pre><code>from dimtensor import DimArray, units\n\n# Voltage and current\nV = DimArray([12.0], units.V)\nI = DimArray([2.0], units.A)\n\n# Resistance: R = V/I\nR = V / I\nprint(f\"Resistance: {R}\")  # 6.0 ohm\n\n# Power: P = V*I\nP = V * I\nprint(f\"Power: {P}\")  # 24.0 W\n</code></pre>"},{"location":"guide/examples/#rc-circuit","title":"RC Circuit","text":"<pre><code>from dimtensor import DimArray, units\nimport numpy as np\n\n# Circuit parameters\nR = DimArray([1000], units.ohm)  # 1 kOhm\nC = DimArray([1e-6], units.F)     # 1 uF\nV0 = DimArray([5.0], units.V)     # Initial voltage\n\n# Time constant\ntau = R * C\nprint(f\"Time constant: {tau.to(units.s)}\")  # 0.001 s = 1 ms\n\n# Voltage decay at t = 2*tau\nt = 2 * tau\nV_t = V0 * np.exp((-t / tau).to(units.rad))  # dimensionless exponent\nprint(f\"Voltage at t=2*tau: {V_t}\")\n</code></pre>"},{"location":"guide/examples/#thermodynamics","title":"Thermodynamics","text":""},{"location":"guide/examples/#ideal-gas-law","title":"Ideal Gas Law","text":"<pre><code>from dimtensor import DimArray, units\n\n# Gas constant (you would define this)\nR_gas = DimArray([8.314], units.J / (units.mol * units.K))\n\n# State variables\nn = DimArray([1.0], units.mol)\nT = DimArray([300], units.K)\nV = DimArray([0.025], units.m**3)\n\n# Pressure: P = nRT/V\nP = n * R_gas * T / V\nprint(f\"Pressure: {P.to(units.Pa)}\")\nprint(f\"Pressure: {P.to(units.atm)}\")\n</code></pre>"},{"location":"guide/examples/#working-with-vectors","title":"Working with Vectors","text":""},{"location":"guide/examples/#3d-velocity-and-speed","title":"3D Velocity and Speed","text":"<pre><code>from dimtensor import DimArray, units, norm, dot\n\n# 3D velocity vector\nvelocity = DimArray([3.0, 4.0, 0.0], units.m / units.s)\n\n# Speed (magnitude)\nspeed = norm(velocity)\nprint(f\"Speed: {speed}\")  # 5.0 m/s\n\n# Kinetic energy\nm = DimArray([2.0], units.kg)\nKE = 0.5 * m * dot(velocity, velocity)\nprint(f\"KE: {KE}\")  # 25.0 J\n</code></pre>"},{"location":"guide/examples/#work-done-by-force","title":"Work Done by Force","text":"<pre><code>from dimtensor import DimArray, units, dot\n\n# Force vector\nF = DimArray([10.0, 5.0, 0.0], units.N)\n\n# Displacement vector\nd = DimArray([3.0, 4.0, 0.0], units.m)\n\n# Work: W = F . d\nW = dot(F, d)\nprint(f\"Work done: {W}\")  # 50.0 J\n</code></pre>"},{"location":"guide/examples/#unit-conversions","title":"Unit Conversions","text":""},{"location":"guide/examples/#distance-and-speed","title":"Distance and Speed","text":"<pre><code>from dimtensor import DimArray, units\n\n# Marathon distance\nmarathon = DimArray([42.195], units.km)\nprint(f\"Marathon: {marathon.to(units.m)}\")      # 42195 m\nprint(f\"Marathon: {marathon.to(units.mile)}\")   # ~26.2 mi\n\n# Speed conversion\nspeed_ms = DimArray([10], units.m / units.s)\nspeed_kmh = speed_ms.to(units.km / units.hour)\nprint(f\"Speed: {speed_kmh}\")  # 36 km/h\n</code></pre>"},{"location":"guide/examples/#energy-units","title":"Energy Units","text":"<pre><code>from dimtensor import DimArray, units\n\n# Energy in different units\nenergy_J = DimArray([1.0], units.J)\nenergy_eV = energy_J.to(units.eV)\nprint(f\"1 J = {energy_eV} eV\")  # ~6.24e18 eV\n</code></pre>"},{"location":"guide/operations/","title":"Array Operations","text":""},{"location":"guide/operations/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>All standard arithmetic operations preserve dimensional correctness:</p> <pre><code>from dimtensor import DimArray, units\n\na = DimArray([1, 2, 3], units.m)\nb = DimArray([4, 5, 6], units.m)\n\n# Addition/subtraction (requires same dimension)\na + b  # [5 7 9] m\na - b  # [-3 -3 -3] m\n\n# Multiplication (dimensions combine)\nc = DimArray([2], units.s)\na * c  # [2 4 6] m*s\n\n# Division (dimensions divide)\na / c  # [0.5 1.0 1.5] m/s\n\n# Power (dimension exponentiated)\na ** 2  # [1 4 9] m^2\n</code></pre>"},{"location":"guide/operations/#reduction-operations","title":"Reduction Operations","text":"<p>Reduce arrays while preserving units:</p> <pre><code>arr = DimArray([[1, 2, 3], [4, 5, 6]], units.m)\n\n# Sum\narr.sum()           # [21] m\narr.sum(axis=0)     # [5 7 9] m\narr.sum(axis=1)     # [6 15] m\n\n# Mean\narr.mean()          # [3.5] m\n\n# Min/Max\narr.min()           # [1] m\narr.max()           # [6] m\n\n# Standard deviation (preserves unit)\narr.std()           # [...] m\n\n# Variance (squares the unit)\narr.var()           # [...] m^2\n</code></pre>"},{"location":"guide/operations/#searching","title":"Searching","text":"<p>Find indices of minimum/maximum values:</p> <pre><code>arr = DimArray([3, 1, 4, 1, 5], units.m)\n\n# Returns plain numpy integers/arrays (not DimArray)\narr.argmin()        # 1\narr.argmax()        # 4\n\n# With axis\narr2d = DimArray([[3, 1], [2, 4]], units.m)\narr2d.argmin(axis=0)  # [1, 0]\narr2d.argmax(axis=1)  # [0, 1]\n</code></pre>"},{"location":"guide/operations/#reshaping","title":"Reshaping","text":"<p>Reshape operations preserve units:</p> <pre><code>arr = DimArray([1, 2, 3, 4, 5, 6], units.m)\n\n# Reshape\narr.reshape((2, 3))      # [[1 2 3] [4 5 6]] m\narr.reshape((3, -1))     # [[1 2] [3 4] [5 6]] m\n\n# Transpose\narr2d = DimArray([[1, 2, 3], [4, 5, 6]], units.m)\narr2d.transpose()        # [[1 4] [2 5] [3 6]] m\n\n# Flatten\narr2d.flatten()          # [1 2 3 4 5 6] m\n</code></pre>"},{"location":"guide/operations/#array-functions","title":"Array Functions","text":"<p>Module-level functions for combining arrays:</p> <pre><code>from dimtensor import DimArray, units, concatenate, stack, split\n\na = DimArray([1, 2], units.m)\nb = DimArray([3, 4], units.m)\n\n# Concatenate (requires same dimension)\nconcatenate([a, b])      # [1 2 3 4] m\n\n# Stack (creates new axis)\nstack([a, b])            # [[1 2] [3 4]] m\nstack([a, b], axis=1)    # [[1 3] [2 4]] m\n\n# Split\narr = DimArray([1, 2, 3, 4], units.m)\nsplit(arr, 2)            # [[1 2] m, [3 4] m]\n</code></pre>"},{"location":"guide/operations/#linear-algebra","title":"Linear Algebra","text":"<p>Linear algebra functions with proper dimension handling:</p> <pre><code>from dimtensor import DimArray, units, dot, matmul, norm\n\n# Dot product (dimensions multiply)\nlength = DimArray([1, 2, 3], units.m)\nforce = DimArray([4, 5, 6], units.N)\nwork = dot(length, force)  # [32] J (m * N = J)\n\n# Matrix multiplication\nA = DimArray([[1, 2], [3, 4]], units.m)\nB = DimArray([[5, 6], [7, 8]], units.s)\nmatmul(A, B)  # Result has dimension m*s\n\n# Norm (preserves unit)\nvelocity = DimArray([3, 4], units.m / units.s)\nspeed = norm(velocity)  # [5] m/s\n</code></pre>"},{"location":"guide/operations/#numpy-ufunc-integration","title":"NumPy ufunc Integration","text":"<p>Use NumPy functions directly:</p> <pre><code>import numpy as np\nfrom dimtensor import DimArray, units\n\n# Trigonometric functions (require dimensionless)\nangle = DimArray([0, 3.14159/2], units.rad)\nnp.sin(angle)  # [0, 1]\nnp.cos(angle)  # [1, 0]\n\n# Exponential/log (require dimensionless)\nx = DimArray([0, 1, 2], units.rad)  # dimensionless\nnp.exp(x)\nnp.log(x + 1)\n\n# sqrt (halves dimension exponents)\narea = DimArray([4, 9, 16], units.m**2)\nnp.sqrt(area)  # [2 3 4] m\n\n# abs (preserves unit)\nvelocity = DimArray([-1, 2, -3], units.m / units.s)\nnp.abs(velocity)  # [1 2 3] m/s\n</code></pre> <p>Dimensional Requirements</p> <p>Functions like <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code> require dimensionless input. Attempting to use them with dimensional quantities raises <code>DimensionError</code>.</p>"},{"location":"guide/units/","title":"Working with Units","text":""},{"location":"guide/units/#available-units","title":"Available Units","text":"<p>dimtensor provides a comprehensive set of SI and common non-SI units.</p>"},{"location":"guide/units/#si-base-units","title":"SI Base Units","text":"Unit Symbol Dimension <code>units.m</code> m Length <code>units.kg</code> kg Mass <code>units.s</code> s Time <code>units.A</code> A Electric current <code>units.K</code> K Temperature <code>units.mol</code> mol Amount of substance <code>units.cd</code> cd Luminous intensity"},{"location":"guide/units/#si-derived-units","title":"SI Derived Units","text":"Unit Symbol Definition <code>units.N</code> N Newton (kg*m/s^2) <code>units.J</code> J Joule (kg*m^2/s^2) <code>units.W</code> W Watt (kg*m^2/s^3) <code>units.Pa</code> Pa Pascal (kg/m/s^2) <code>units.Hz</code> Hz Hertz (1/s) <code>units.V</code> V Volt <code>units.ohm</code> ohm Ohm <code>units.C</code> C Coulomb"},{"location":"guide/units/#common-non-si-units","title":"Common Non-SI Units","text":"Unit Symbol Relation to SI <code>units.km</code> km 1000 m <code>units.cm</code> cm 0.01 m <code>units.mm</code> mm 0.001 m <code>units.mile</code> mi 1609.344 m <code>units.hour</code> h 3600 s <code>units.minute</code> min 60 s <code>units.eV</code> eV 1.602e-19 J <code>units.atm</code> atm 101325 Pa <code>units.rad</code> rad Dimensionless <code>units.deg</code> deg pi/180 rad"},{"location":"guide/units/#creating-compound-units","title":"Creating Compound Units","text":"<p>Build complex units using arithmetic:</p> <pre><code>from dimtensor import units\n\n# Velocity\nvelocity_unit = units.m / units.s\n\n# Acceleration\naccel_unit = units.m / units.s**2\n\n# Energy density\nenergy_density = units.J / units.m**3\n\n# Pressure (alternative)\npressure = units.kg / (units.m * units.s**2)\n</code></pre>"},{"location":"guide/units/#unit-simplification","title":"Unit Simplification","text":"<p>dimtensor automatically simplifies compound units to their SI derived equivalents:</p> <pre><code>from dimtensor import DimArray, units\n\n# Force calculation\nmass = DimArray([2.0], units.kg)\naccel = DimArray([9.8], units.m / units.s**2)\nforce = mass * accel\n\nprint(force)  # [19.6] N  (not kg*m/s^2)\n\n# Energy calculation\ndistance = DimArray([10.0], units.m)\nwork = force * distance\n\nprint(work)  # [196.] J  (not kg*m^2/s^2)\n</code></pre>"},{"location":"guide/units/#unit-conversion","title":"Unit Conversion","text":"<p>Convert between compatible units with <code>.to()</code>:</p> <pre><code># Length conversions\ndistance = DimArray([5.0], units.km)\nprint(distance.to(units.m))     # [5000.] m\nprint(distance.to(units.mile))  # [3.10685596] mi\n\n# Time conversions\ntime = DimArray([3600.0], units.s)\nprint(time.to(units.hour))  # [1.] h\n\n# Energy conversions\nenergy = DimArray([1.0], units.J)\nprint(energy.to(units.eV))  # [6.242e+18] eV\n</code></pre> <p>Incompatible Conversions</p> <p>Attempting to convert between incompatible dimensions raises <code>UnitConversionError</code>:</p> <pre><code>distance = DimArray([1.0], units.m)\ndistance.to(units.s)  # UnitConversionError!\n</code></pre>"},{"location":"guide/units/#dimensionless-quantities","title":"Dimensionless Quantities","text":"<p>Some quantities have no physical dimension:</p> <pre><code># Angles\nangle = DimArray([3.14159], units.rad)\nprint(angle.is_dimensionless)  # True\n\n# Ratios\nratio = distance1 / distance2  # Dimensionless\n\n# Works with trig functions\nimport numpy as np\nnp.sin(angle)  # Works because angle is dimensionless\n</code></pre>"},{"location":"performance/benchmarks/","title":"Performance Benchmarks","text":"<p>dimtensor adds unit tracking to your arrays. This page shows the performance characteristics and overhead compared to raw operations.</p>"},{"location":"performance/benchmarks/#summary","title":"Summary","text":"Framework Overhead vs Raw Notes NumPy 2-5x Acceptable for most scientific work PyTorch 2-4x GPU operations amortize overhead JAX 2-3x JIT compilation reduces overhead"},{"location":"performance/benchmarks/#numpy-benchmarks","title":"NumPy Benchmarks","text":""},{"location":"performance/benchmarks/#array-creation","title":"Array Creation","text":"<pre><code>import numpy as np\nfrom dimtensor import DimArray, units\nimport timeit\n\n# Raw NumPy\n%timeit np.array([1.0] * 1000)\n# ~2.5 \u03bcs\n\n# dimtensor\n%timeit DimArray([1.0] * 1000, units.m)\n# ~5 \u03bcs (2x overhead)\n</code></pre>"},{"location":"performance/benchmarks/#arithmetic-operations","title":"Arithmetic Operations","text":"<pre><code>a_np = np.random.randn(10000)\nb_np = np.random.randn(10000)\n\na_dim = DimArray(a_np, units.m)\nb_dim = DimArray(b_np, units.m)\n\n# Raw NumPy\n%timeit a_np + b_np\n# ~5 \u03bcs\n\n# dimtensor\n%timeit a_dim + b_dim\n# ~15 \u03bcs (3x overhead)\n</code></pre>"},{"location":"performance/benchmarks/#large-array-operations","title":"Large Array Operations","text":"<p>For larger arrays, the relative overhead decreases:</p> <pre><code># 1 million elements\na_np = np.random.randn(1_000_000)\nb_np = np.random.randn(1_000_000)\n\na_dim = DimArray(a_np, units.m)\nb_dim = DimArray(b_np, units.m)\n\n# Raw NumPy\n%timeit a_np * b_np\n# ~1.2 ms\n\n# dimtensor\n%timeit a_dim * b_dim\n# ~1.5 ms (1.25x overhead - much better!)\n</code></pre> <p>Key insight: Overhead is relatively constant, so larger arrays have proportionally less overhead.</p>"},{"location":"performance/benchmarks/#pytorch-benchmarks","title":"PyTorch Benchmarks","text":""},{"location":"performance/benchmarks/#cpu-operations","title":"CPU Operations","text":"<pre><code>import torch\nfrom dimtensor.torch import DimTensor\nfrom dimtensor import units\n\na_torch = torch.randn(10000)\nb_torch = torch.randn(10000)\n\na_dim = DimTensor(a_torch, units.m)\nb_dim = DimTensor(b_torch, units.m)\n\n# Raw PyTorch\n%timeit a_torch + b_torch\n# ~8 \u03bcs\n\n# dimtensor\n%timeit a_dim + b_dim\n# ~25 \u03bcs (3x overhead)\n</code></pre>"},{"location":"performance/benchmarks/#gpu-operations","title":"GPU Operations","text":"<p>GPU operations benefit significantly because the overhead is CPU-bound:</p> <pre><code># On GPU\na_gpu = torch.randn(1_000_000, device='cuda')\nb_gpu = torch.randn(1_000_000, device='cuda')\n\na_dim_gpu = DimTensor(a_gpu, units.m)\nb_dim_gpu = DimTensor(b_gpu, units.m)\n\n# Raw PyTorch GPU\n%timeit torch.cuda.synchronize(); _ = a_gpu * b_gpu; torch.cuda.synchronize()\n# ~50 \u03bcs\n\n# dimtensor GPU\n%timeit torch.cuda.synchronize(); _ = a_dim_gpu * b_dim_gpu; torch.cuda.synchronize()\n# ~55 \u03bcs (1.1x overhead - negligible!)\n</code></pre> <p>Key insight: GPU operations amortize the CPU-side unit tracking overhead.</p>"},{"location":"performance/benchmarks/#autograd","title":"Autograd","text":"<pre><code>a = DimTensor(torch.randn(1000, requires_grad=True), units.m)\nb = DimTensor(torch.randn(1000), units.s)\n\ndef forward():\n    c = a / b\n    return c.sum()\n\n# Backward pass\n%timeit loss = forward(); loss.backward()\n# Overhead: ~2x vs raw PyTorch autograd\n</code></pre>"},{"location":"performance/benchmarks/#jax-benchmarks","title":"JAX Benchmarks","text":""},{"location":"performance/benchmarks/#jit-compilation","title":"JIT Compilation","text":"<p>JIT compilation significantly reduces dimtensor overhead:</p> <pre><code>import jax\nimport jax.numpy as jnp\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n@jax.jit\ndef compute_raw(a, b):\n    return a * b + a\n\n@jax.jit\ndef compute_dim(a, b):\n    return a * b + a\n\na_jax = jnp.ones(10000)\nb_jax = jnp.ones(10000)\n\na_dim = DimArray(jnp.ones(10000), units.m)\nb_dim = DimArray(jnp.ones(10000), units.m)\n\n# After warmup\n%timeit compute_raw(a_jax, b_jax).block_until_ready()\n# ~15 \u03bcs\n\n%timeit compute_dim(a_dim, b_dim).data.block_until_ready()\n# ~25 \u03bcs (1.7x overhead)\n</code></pre>"},{"location":"performance/benchmarks/#vmap","title":"vmap","text":"<pre><code>@jax.jit\n@jax.vmap\ndef batched_compute(x):\n    return x ** 2\n\nx_raw = jnp.ones((100, 1000))\nx_dim = DimArray(jnp.ones((100, 1000)), units.m)\n\n%timeit batched_compute(x_raw).block_until_ready()\n# ~20 \u03bcs\n\n%timeit batched_compute(x_dim).data.block_until_ready()\n# ~35 \u03bcs (1.75x overhead)\n</code></pre>"},{"location":"performance/benchmarks/#optimization-tips","title":"Optimization Tips","text":""},{"location":"performance/benchmarks/#1-use-larger-arrays","title":"1. Use Larger Arrays","text":"<p>Overhead is relatively constant, so batch your operations:</p> <pre><code># Slower: Many small operations\nfor i in range(1000):\n    result = DimArray([values[i]], units.m) * scalar\n\n# Faster: One large operation\nresult = DimArray(values, units.m) * scalar\n</code></pre>"},{"location":"performance/benchmarks/#2-use-gpu-for-large-computations","title":"2. Use GPU for Large Computations","text":"<p>GPU operations have negligible overhead:</p> <pre><code># Move to GPU for large arrays\ndata = DimTensor(torch.randn(1_000_000), units.m)\ndata_gpu = data.cuda()  # Overhead becomes negligible\n</code></pre>"},{"location":"performance/benchmarks/#3-use-jax-jit","title":"3. Use JAX JIT","text":"<p>JIT compilation reduces overhead significantly:</p> <pre><code>@jax.jit\ndef physics_simulation(state):\n    # All unit checking happens at trace time\n    # Compiled code runs at near-native speed\n    return new_state\n</code></pre>"},{"location":"performance/benchmarks/#4-extract-data-for-tight-loops","title":"4. Extract Data for Tight Loops","text":"<p>For performance-critical inner loops:</p> <pre><code># Extract raw data for tight loop\nraw_data = arr.data\nraw_unit = arr.unit\n\nfor i in range(1000000):\n    # Pure NumPy operations\n    raw_data[i] = compute(raw_data[i])\n\n# Reconstruct with units\nresult = DimArray(raw_data, raw_unit)\n</code></pre>"},{"location":"performance/benchmarks/#5-disable-uncertainty-when-not-needed","title":"5. Disable Uncertainty When Not Needed","text":"<p>Uncertainty propagation adds overhead:</p> <pre><code># With uncertainty (slower)\narr = DimArray([1, 2, 3], units.m, uncertainty=[0.1, 0.1, 0.1])\n\n# Without uncertainty (faster)\narr = DimArray([1, 2, 3], units.m)\n</code></pre>"},{"location":"performance/benchmarks/#comparison-with-other-libraries","title":"Comparison with Other Libraries","text":"Library Relative Overhead GPU Support dimtensor 2-5x Yes (PyTorch) Pint 2-5x No Astropy 2-3x No unyt 1.5-3x No <p>dimtensor's overhead is comparable to other unit libraries, with the added benefit of GPU acceleration.</p>"},{"location":"performance/benchmarks/#when-performance-matters","title":"When Performance Matters","text":"<p>For most scientific applications, the 2-5x overhead is acceptable because:</p> <ol> <li>I/O is usually the bottleneck - File reading, network, etc.</li> <li>Bugs are expensive - Dimensional errors caught early save hours of debugging</li> <li>GPU amortizes overhead - Large computations on GPU have negligible overhead</li> <li>Correctness &gt; Speed - A fast wrong answer is worse than a slow correct one</li> </ol> <p>If you find dimtensor is your bottleneck, consider:</p> <ol> <li>Profiling to confirm it's actually the issue</li> <li>Using GPU acceleration</li> <li>Extracting raw data for the critical section</li> <li>Opening an issue for optimization suggestions</li> </ol>"},{"location":"performance/benchmarks/#running-your-own-benchmarks","title":"Running Your Own Benchmarks","text":"<p>dimtensor includes benchmarking utilities:</p> <pre><code>from dimtensor.benchmarks import benchmark_operation\n\n# Benchmark a specific operation\nresults = benchmark_operation(\n    operation=lambda a, b: a * b,\n    sizes=[100, 1000, 10000, 100000],\n    units_a=units.m,\n    units_b=units.s,\n)\n\nprint(results)\n</code></pre>"},{"location":"troubleshooting/errors/","title":"Common Errors and How to Fix Them","text":"<p>This page covers the most common errors you'll encounter when using dimtensor and how to resolve them.</p>"},{"location":"troubleshooting/errors/#dimensionerror","title":"DimensionError","text":""},{"location":"troubleshooting/errors/#cannot-addsubtract-incompatible-dimensions","title":"Cannot add/subtract incompatible dimensions","text":"<p>Error: <pre><code>DimensionError: cannot add m/s to m/s^2\n</code></pre></p> <p>Cause: You're trying to add or subtract quantities with different dimensions. This is a physics error - you can't add velocity to acceleration.</p> <p>Solution: Ensure both operands have the same dimensions:</p> <pre><code>from dimtensor import DimArray, units\n\nvelocity = DimArray([10], units.m / units.s)\nacceleration = DimArray([9.8], units.m / units.s**2)\ntime = DimArray([2], units.s)\n\n# Wrong: Adding velocity to acceleration\n# velocity + acceleration  # DimensionError!\n\n# Right: Convert acceleration to velocity change first\nvelocity_change = acceleration * time  # Now has units m/s\ntotal_velocity = velocity + velocity_change  # Works!\n</code></pre>"},{"location":"troubleshooting/errors/#cannot-compare-incompatible-dimensions","title":"Cannot compare incompatible dimensions","text":"<p>Error: <pre><code>DimensionError: cannot compare m to s\n</code></pre></p> <p>Cause: Comparing quantities with different dimensions doesn't make physical sense.</p> <p>Solution: Only compare quantities with the same dimensions:</p> <pre><code># Wrong\nlength = DimArray([10], units.m)\ntime = DimArray([5], units.s)\n# length &gt; time  # DimensionError!\n\n# Right: Compare same dimensions\nlength1 = DimArray([10], units.m)\nlength2 = DimArray([5], units.m)\nlength1 &gt; length2  # True\n</code></pre>"},{"location":"troubleshooting/errors/#unitconversionerror","title":"UnitConversionError","text":""},{"location":"troubleshooting/errors/#cannot-convert-between-incompatible-units","title":"Cannot convert between incompatible units","text":"<p>Error: <pre><code>UnitConversionError: cannot convert m to s\n</code></pre></p> <p>Cause: Attempting to convert between units that measure different physical quantities.</p> <p>Solution: Only convert between compatible units:</p> <pre><code>from dimtensor import DimArray, units\n\ndistance = DimArray([1000], units.m)\n\n# Wrong: meters to seconds (different dimensions)\n# distance.to(units.s)  # UnitConversionError!\n\n# Right: meters to kilometers (same dimension)\ndistance.to(units.km)  # 1 km\n</code></pre>"},{"location":"troubleshooting/errors/#unit-not-found","title":"Unit not found","text":"<p>Error: <pre><code>AttributeError: module 'dimtensor.units' has no attribute 'xyz'\n</code></pre></p> <p>Cause: The unit you're trying to use doesn't exist in dimtensor.</p> <p>Solution: Check the available units or use domain-specific units:</p> <pre><code>from dimtensor import units\n\n# Common SI units\nunits.m      # meter\nunits.kg     # kilogram\nunits.s      # second\nunits.A      # ampere\nunits.K      # kelvin\nunits.mol    # mole\nunits.cd     # candela\n\n# Derived units\nunits.N      # newton\nunits.J      # joule\nunits.W      # watt\nunits.Pa     # pascal\nunits.Hz     # hertz\n\n# For domain-specific units\nfrom dimtensor.domains.astronomy import parsec, solar_mass\nfrom dimtensor.domains.chemistry import molar, dalton\nfrom dimtensor.domains.engineering import MPa, hp\n</code></pre>"},{"location":"troubleshooting/errors/#shape-errors","title":"Shape Errors","text":""},{"location":"troubleshooting/errors/#incompatible-shapes-for-operation","title":"Incompatible shapes for operation","text":"<p>Error: <pre><code>ValueError: operands could not be broadcast together with shapes (3,) (4,)\n</code></pre></p> <p>Cause: NumPy broadcasting rules still apply. Arrays must have compatible shapes.</p> <p>Solution: Ensure arrays can be broadcast together:</p> <pre><code>from dimtensor import DimArray, units\n\na = DimArray([1, 2, 3], units.m)      # shape (3,)\nb = DimArray([1, 2, 3, 4], units.m)   # shape (4,)\n\n# Wrong: Incompatible shapes\n# a + b  # ValueError!\n\n# Right: Use compatible shapes\nb = DimArray([1, 2, 3], units.m)      # shape (3,)\na + b  # Works!\n\n# Or use broadcasting\na = DimArray([[1], [2], [3]], units.m)    # shape (3, 1)\nb = DimArray([1, 2, 3, 4], units.m)       # shape (4,)\na + b  # Broadcasting works: shape (3, 4)\n</code></pre>"},{"location":"troubleshooting/errors/#pytorch-specific-errors","title":"PyTorch-Specific Errors","text":""},{"location":"troubleshooting/errors/#tensor-dtype-mismatch","title":"Tensor dtype mismatch","text":"<p>Error: <pre><code>RuntimeError: expected scalar type Float but found Double\n</code></pre></p> <p>Solution: Ensure consistent dtypes:</p> <pre><code>from dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\n# Specify dtype explicitly\na = DimTensor(torch.tensor([1.0, 2.0], dtype=torch.float32), units.m)\nb = DimTensor(torch.tensor([3.0, 4.0], dtype=torch.float32), units.m)\na + b  # Works!\n</code></pre>"},{"location":"troubleshooting/errors/#gradient-computation-on-integer-tensor","title":"Gradient computation on integer tensor","text":"<p>Error: <pre><code>RuntimeError: Only Tensors of floating point dtype can require gradients\n</code></pre></p> <p>Solution: Use floating point tensors for autograd:</p> <pre><code>from dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\n# Wrong: Integer tensor\n# v = DimTensor(torch.tensor([1, 2, 3], requires_grad=True), units.m)\n\n# Right: Float tensor\nv = DimTensor(torch.tensor([1.0, 2.0, 3.0], requires_grad=True), units.m)\n</code></pre>"},{"location":"troubleshooting/errors/#device-mismatch","title":"Device mismatch","text":"<p>Error: <pre><code>RuntimeError: Expected all tensors to be on the same device\n</code></pre></p> <p>Solution: Move all tensors to the same device:</p> <pre><code>from dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\na = DimTensor(torch.tensor([1.0, 2.0]), units.m).cuda()\nb = DimTensor(torch.tensor([3.0, 4.0]), units.m)  # On CPU\n\n# Wrong: Mixed devices\n# a + b  # RuntimeError!\n\n# Right: Same device\nb = b.cuda()\na + b  # Works!\n</code></pre>"},{"location":"troubleshooting/errors/#jax-specific-errors","title":"JAX-Specific Errors","text":""},{"location":"troubleshooting/errors/#jit-compilation-issues","title":"JIT compilation issues","text":"<p>Error: <pre><code>jax.errors.TracerArrayConversionError: ...\n</code></pre></p> <p>Cause: JAX's tracing doesn't work with certain Python operations on traced values.</p> <p>Solution: Ensure your function uses JAX operations:</p> <pre><code>import jax\nimport jax.numpy as jnp\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n# Wrong: Python conditionals on traced values\n@jax.jit\ndef bad_function(x):\n    if x.data[0] &gt; 0:  # Python if on traced value\n        return x * 2\n    return x\n\n# Right: Use JAX conditionals\n@jax.jit\ndef good_function(x):\n    return jax.lax.cond(\n        x.data[0] &gt; 0,\n        lambda: x * 2,\n        lambda: x\n    )\n</code></pre>"},{"location":"troubleshooting/errors/#uncertainty-errors","title":"Uncertainty Errors","text":""},{"location":"troubleshooting/errors/#uncertainty-shape-mismatch","title":"Uncertainty shape mismatch","text":"<p>Error: <pre><code>ValueError: uncertainty must have same shape as data\n</code></pre></p> <p>Solution: Ensure uncertainty array matches data shape:</p> <pre><code>from dimtensor import DimArray, units\n\n# Wrong: Mismatched shapes\n# arr = DimArray([1, 2, 3], units.m, uncertainty=[0.1, 0.2])\n\n# Right: Same shape\narr = DimArray([1, 2, 3], units.m, uncertainty=[0.1, 0.2, 0.3])\n</code></pre>"},{"location":"troubleshooting/errors/#io-errors","title":"I/O Errors","text":""},{"location":"troubleshooting/errors/#file-format-not-recognized","title":"File format not recognized","text":"<p>Error: <pre><code>ValueError: Unknown file format\n</code></pre></p> <p>Solution: Use the correct I/O function for your file format:</p> <pre><code>from dimtensor.io import (\n    save_json, load_json,\n    save_hdf5, load_hdf5,\n    save_parquet, load_parquet,\n    save_netcdf, load_netcdf,\n    to_dataframe, from_dataframe,\n    to_xarray, from_xarray\n)\n\n# Use the right function for each format\nsave_json(arr, \"data.json\")\nsave_hdf5(arr, \"data.h5\")\nsave_parquet(arr, \"data.parquet\")\nsave_netcdf(arr, \"data.nc\")\n</code></pre>"},{"location":"troubleshooting/errors/#missing-optional-dependency","title":"Missing optional dependency","text":"<p>Error: <pre><code>ImportError: HDF5 support requires h5py. Install with: pip install h5py\n</code></pre></p> <p>Solution: Install the required optional dependency:</p> <pre><code>pip install dimtensor[hdf5]    # For HDF5 support\npip install dimtensor[parquet] # For Parquet support\npip install dimtensor[netcdf]  # For NetCDF support\npip install dimtensor[all]     # All optional dependencies\n</code></pre>"},{"location":"troubleshooting/errors/#still-having-issues","title":"Still Having Issues?","text":"<p>If you can't find your error here:</p> <ol> <li>Check the FAQ for common questions</li> <li>Search GitHub Issues for similar problems</li> <li>Open a new issue with:</li> <li>Your dimtensor version (<code>pip show dimtensor</code>)</li> <li>Python version</li> <li>Minimal code to reproduce the error</li> <li>Full error traceback</li> </ol>"},{"location":"troubleshooting/faq/","title":"Frequently Asked Questions","text":""},{"location":"troubleshooting/faq/#general","title":"General","text":""},{"location":"troubleshooting/faq/#what-is-dimtensor","title":"What is dimtensor?","text":"<p>dimtensor is a Python library that adds physical unit tracking to NumPy, PyTorch, and JAX arrays. It catches dimensional errors at operation time, preventing bugs that would otherwise only be discovered after expensive computations.</p>"},{"location":"troubleshooting/faq/#how-does-dimtensor-compare-to-pint","title":"How does dimtensor compare to Pint?","text":"<p>See our detailed comparison. The key differences:</p> <ul> <li>dimtensor has native PyTorch/JAX support with autograd</li> <li>Pint has more flexible unit customization</li> </ul>"},{"location":"troubleshooting/faq/#is-dimtensor-production-ready","title":"Is dimtensor production-ready?","text":"<p>Yes. dimtensor is at version 1.x with comprehensive test coverage, type hints, and stable API.</p>"},{"location":"troubleshooting/faq/#units","title":"Units","text":""},{"location":"troubleshooting/faq/#what-units-are-available","title":"What units are available?","text":"<p>dimtensor includes:</p> <ul> <li>SI base units: m, kg, s, A, K, mol, cd</li> <li>SI derived units: N, J, W, Pa, Hz, V, C, F, etc.</li> <li>Common units: km, cm, mm, g, mg, min, hr, etc.</li> <li>Domain-specific units:</li> <li>Astronomy: parsec, AU, light_year, solar_mass</li> <li>Chemistry: molar, dalton, ppm</li> <li>Engineering: MPa, hp, BTU, kWh</li> </ul> <pre><code>from dimtensor import units\nfrom dimtensor.domains.astronomy import parsec\nfrom dimtensor.domains.chemistry import molar\nfrom dimtensor.domains.engineering import MPa\n</code></pre>"},{"location":"troubleshooting/faq/#how-do-i-create-custom-units","title":"How do I create custom units?","text":"<p>Currently, dimtensor focuses on standard scientific units. For highly custom unit systems, consider using Pint alongside dimtensor.</p>"},{"location":"troubleshooting/faq/#how-do-i-convert-between-units","title":"How do I convert between units?","text":"<p>Use the <code>.to()</code> method:</p> <pre><code>from dimtensor import DimArray, units\n\ndistance = DimArray([1000], units.m)\nin_km = distance.to(units.km)  # 1 km\nin_miles = distance.to(units.mile)  # ~0.621 mi\n</code></pre>"},{"location":"troubleshooting/faq/#why-cant-i-convert-meters-to-seconds","title":"Why can't I convert meters to seconds?","text":"<p>Units can only be converted to other units with the same dimensions. Meters (length) and seconds (time) measure different physical quantities. This is a feature, not a bug - it prevents physically meaningless conversions.</p>"},{"location":"troubleshooting/faq/#performance","title":"Performance","text":""},{"location":"troubleshooting/faq/#whats-the-performance-overhead","title":"What's the performance overhead?","text":"<p>dimtensor adds approximately 2-5x overhead compared to raw NumPy for typical operations. This overhead comes from:</p> <ul> <li>Unit checking during operations</li> <li>Creating new DimArray wrappers for results</li> </ul> <p>For most scientific applications, this overhead is negligible compared to the bugs it prevents.</p>"},{"location":"troubleshooting/faq/#how-can-i-improve-performance","title":"How can I improve performance?","text":"<ol> <li>Use larger arrays - Overhead is relatively smaller for bigger arrays</li> <li>Batch operations - Fewer operations means less overhead</li> <li>Use GPU - For PyTorch, GPU operations amortize the overhead</li> <li>Strip units in tight loops - For performance-critical inner loops, extract raw data:</li> </ol> <pre><code># For tight loops, extract raw data\nraw_data = arr.data\n# ... perform operations on raw_data ...\nresult = DimArray(raw_data, arr.unit)\n</code></pre>"},{"location":"troubleshooting/faq/#does-dimtensor-support-gpu","title":"Does dimtensor support GPU?","text":"<p>Yes, via PyTorch integration:</p> <pre><code>from dimtensor.torch import DimTensor\nfrom dimtensor import units\nimport torch\n\narr = DimTensor(torch.randn(1000, 1000), units.m)\narr_gpu = arr.cuda()  # Units preserved on GPU\n</code></pre>"},{"location":"troubleshooting/faq/#integration","title":"Integration","text":""},{"location":"troubleshooting/faq/#can-i-use-dimtensor-with-pandas","title":"Can I use dimtensor with pandas?","text":"<p>Yes, dimtensor supports pandas DataFrame conversion:</p> <pre><code>from dimtensor import DimArray, units\nfrom dimtensor.io import to_dataframe, from_dataframe\n\ndata = {\n    \"position\": DimArray([1, 2, 3], units.m),\n    \"velocity\": DimArray([10, 20, 30], units.m / units.s)\n}\ndf = to_dataframe(data)\narrays = from_dataframe(df)\n</code></pre>"},{"location":"troubleshooting/faq/#can-i-use-dimtensor-with-xarray","title":"Can I use dimtensor with xarray?","text":"<p>Yes:</p> <pre><code>from dimtensor import DimArray, units\nfrom dimtensor.io import to_xarray, from_xarray\n\narr = DimArray([1.0, 2.0, 3.0], units.m)\nda = to_xarray(arr, name=\"distance\", dims=(\"x\",))\nrestored = from_xarray(da)\n</code></pre>"},{"location":"troubleshooting/faq/#does-dimtensor-work-with-numpy-functions","title":"Does dimtensor work with NumPy functions?","text":"<p>Yes, most NumPy functions work with DimArray:</p> <pre><code>import numpy as np\nfrom dimtensor import DimArray, units\n\narr = DimArray([1, 4, 9], units.m**2)\nresult = np.sqrt(arr)  # Returns DimArray with units m\n\n# Functions requiring dimensionless input\nangle = DimArray([0, np.pi/2, np.pi], units.dimensionless)\nnp.sin(angle)  # Works\n</code></pre>"},{"location":"troubleshooting/faq/#does-jax-jit-work-with-dimtensor","title":"Does JAX JIT work with dimtensor?","text":"<p>Yes, DimArray is registered as a JAX pytree:</p> <pre><code>import jax\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n@jax.jit\ndef kinetic_energy(m, v):\n    return 0.5 * m * v**2\n\nm = DimArray([1.0], units.kg)\nv = DimArray([10.0], units.m / units.s)\nE = kinetic_energy(m, v)  # JIT works, units preserved\n</code></pre>"},{"location":"troubleshooting/faq/#uncertainty","title":"Uncertainty","text":""},{"location":"troubleshooting/faq/#how-does-uncertainty-propagation-work","title":"How does uncertainty propagation work?","text":"<p>dimtensor propagates uncertainties in quadrature through all operations:</p> <pre><code>from dimtensor import DimArray, units\n\nx = DimArray([10.0], units.m, uncertainty=[0.1])\ny = DimArray([5.0], units.m, uncertainty=[0.2])\n\n# Addition: uncertainty adds in quadrature\nz = x + y  # 15.0 +/- 0.224 m\n\n# Multiplication: relative uncertainties add in quadrature\na = x * y  # 50.0 +/- 1.12 m^2\n</code></pre>"},{"location":"troubleshooting/faq/#can-i-disable-uncertainty-propagation","title":"Can I disable uncertainty propagation?","text":"<p>Create arrays without the <code>uncertainty</code> parameter:</p> <pre><code># With uncertainty\narr = DimArray([10.0], units.m, uncertainty=[0.1])\n\n# Without uncertainty (faster)\narr = DimArray([10.0], units.m)\n</code></pre>"},{"location":"troubleshooting/faq/#io","title":"I/O","text":""},{"location":"troubleshooting/faq/#what-file-formats-are-supported","title":"What file formats are supported?","text":"<ul> <li>JSON</li> <li>HDF5 (requires <code>h5py</code>)</li> <li>Parquet (requires <code>pyarrow</code>)</li> <li>NetCDF (requires <code>netcdf4</code>)</li> <li>pandas DataFrame</li> <li>xarray DataArray</li> </ul>"},{"location":"troubleshooting/faq/#how-do-i-install-optional-dependencies","title":"How do I install optional dependencies?","text":"<pre><code>pip install dimtensor[hdf5]    # HDF5 support\npip install dimtensor[parquet] # Parquet support\npip install dimtensor[netcdf]  # NetCDF support\npip install dimtensor[all]     # All dependencies\n</code></pre>"},{"location":"troubleshooting/faq/#are-units-preserved-when-savingloading","title":"Are units preserved when saving/loading?","text":"<p>Yes, all I/O functions preserve units:</p> <pre><code>from dimtensor import DimArray, units\nfrom dimtensor.io import save_json, load_json\n\narr = DimArray([1, 2, 3], units.m / units.s)\nsave_json(arr, \"velocity.json\")\nloaded = load_json(\"velocity.json\")\nprint(loaded.unit)  # m/s\n</code></pre>"},{"location":"troubleshooting/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"troubleshooting/faq/#why-am-i-getting-dimensionerror","title":"Why am I getting DimensionError?","text":"<p>This means you're trying to combine quantities with incompatible dimensions (like adding meters to seconds). This is dimtensor working correctly - it's catching a physics error. See Common Errors for solutions.</p>"},{"location":"troubleshooting/faq/#why-doesnt-my-custom-numpy-function-work","title":"Why doesn't my custom NumPy function work?","text":"<p>Some NumPy functions aren't supported yet. You can:</p> <ol> <li> <p>Extract raw data, apply the function, and reconstruct:    <pre><code>result_data = custom_function(arr.data)\nresult = DimArray(result_data, expected_unit)\n</code></pre></p> </li> <li> <p>Open an issue requesting support for that function.</p> </li> </ol>"},{"location":"troubleshooting/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ol> <li>Check this FAQ and Common Errors</li> <li>Search GitHub Issues</li> <li>Open a new issue with your question</li> <li>Join GitHub Discussions</li> </ol>"},{"location":"troubleshooting/migration/","title":"Migration Guide","text":"<p>This guide helps you migrate existing code to dimtensor from other libraries or raw NumPy.</p>"},{"location":"troubleshooting/migration/#from-raw-numpy","title":"From Raw NumPy","text":"<p>If you're adding units to existing NumPy code:</p>"},{"location":"troubleshooting/migration/#before-raw-numpy","title":"Before (Raw NumPy)","text":"<pre><code>import numpy as np\n\n# No unit safety - bugs can go unnoticed\nvelocity = np.array([10, 20, 30])  # m/s (implicit)\ntime = np.array([1, 2, 3])          # s (implicit)\ndistance = velocity * time          # Hopefully correct...\n\n# This bug compiles fine but is physically wrong\nacceleration = np.array([9.8])      # m/s^2 (implicit)\nwrong = velocity + acceleration     # No error! But meaningless.\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor","title":"After (dimtensor)","text":"<pre><code>from dimtensor import DimArray, units\n\n# Units are explicit and checked\nvelocity = DimArray([10, 20, 30], units.m / units.s)\ntime = DimArray([1, 2, 3], units.s)\ndistance = velocity * time  # [10 40 90] m\n\n# Bug caught immediately\nacceleration = DimArray([9.8], units.m / units.s**2)\nvelocity + acceleration  # DimensionError: cannot add m/s to m/s^2\n</code></pre>"},{"location":"troubleshooting/migration/#migration-steps","title":"Migration Steps","text":"<ol> <li> <p>Import dimtensor <pre><code>from dimtensor import DimArray, units\n</code></pre></p> </li> <li> <p>Wrap arrays with units <pre><code># Before\ndata = np.array([1, 2, 3])\n\n# After\ndata = DimArray([1, 2, 3], units.m)\n</code></pre></p> </li> <li> <p>Access raw data when needed <pre><code>raw = data.data  # Get underlying numpy array\n</code></pre></p> </li> <li> <p>Update function signatures <pre><code># Before\ndef calculate_energy(mass, velocity):\n    return 0.5 * mass * velocity**2\n\n# After (works the same, but now type-safe)\ndef calculate_energy(mass: DimArray, velocity: DimArray) -&gt; DimArray:\n    return 0.5 * mass * velocity**2\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/migration/#from-pint","title":"From Pint","text":""},{"location":"troubleshooting/migration/#key-differences","title":"Key Differences","text":"Pint dimtensor <code>ureg = pint.UnitRegistry()</code> <code>from dimtensor import units</code> <code>10 * ureg.meter</code> <code>DimArray([10], units.m)</code> <code>value.magnitude</code> <code>arr.data</code> <code>value.units</code> <code>arr.unit</code> <code>value.to('km')</code> <code>arr.to(units.km)</code>"},{"location":"troubleshooting/migration/#before-pint","title":"Before (Pint)","text":"<pre><code>import pint\n\nureg = pint.UnitRegistry()\n\nvelocity = 10 * ureg.meter / ureg.second\ntime = 5 * ureg.second\ndistance = velocity * time\n\n# Convert units\ndistance_km = distance.to('kilometer')\n\n# Get magnitude\nvalue = distance.magnitude\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor_1","title":"After (dimtensor)","text":"<pre><code>from dimtensor import DimArray, units\n\nvelocity = DimArray([10], units.m / units.s)\ntime = DimArray([5], units.s)\ndistance = velocity * time\n\n# Convert units\ndistance_km = distance.to(units.km)\n\n# Get raw data\nvalue = distance.data\n</code></pre>"},{"location":"troubleshooting/migration/#migration-script","title":"Migration Script","text":"<pre><code># Quick find-and-replace patterns:\n# ureg.meter -&gt; units.m\n# ureg.second -&gt; units.s\n# ureg.kilogram -&gt; units.kg\n# .magnitude -&gt; .data\n# .units -&gt; .unit\n# * ureg.unit -&gt; DimArray([...], units.unit)\n</code></pre>"},{"location":"troubleshooting/migration/#from-astropy","title":"From Astropy","text":""},{"location":"troubleshooting/migration/#key-differences_1","title":"Key Differences","text":"Astropy dimtensor <code>from astropy import units as u</code> <code>from dimtensor import units</code> <code>10 * u.m</code> <code>DimArray([10], units.m)</code> <code>value.value</code> <code>arr.data</code> <code>value.unit</code> <code>arr.unit</code> <code>value.to(u.km)</code> <code>arr.to(units.km)</code>"},{"location":"troubleshooting/migration/#before-astropy","title":"Before (Astropy)","text":"<pre><code>from astropy import units as u\nfrom astropy import constants as const\n\nmass = 1.0 * u.kg\nvelocity = 10 * u.m / u.s\nenergy = 0.5 * mass * velocity**2\n\n# Physical constants\nc = const.c\nE = mass * c**2\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor_2","title":"After (dimtensor)","text":"<pre><code>from dimtensor import DimArray, units, constants\n\nmass = DimArray([1.0], units.kg)\nvelocity = DimArray([10], units.m / units.s)\nenergy = 0.5 * mass * velocity**2\n\n# Physical constants\nc = constants.c\nE = mass * c**2\n</code></pre>"},{"location":"troubleshooting/migration/#astronomy-units","title":"Astronomy Units","text":"<pre><code># Astropy\nfrom astropy import units as u\ndistance = 10 * u.pc\n\n# dimtensor\nfrom dimtensor import DimArray\nfrom dimtensor.domains.astronomy import parsec\ndistance = DimArray([10], parsec)\n</code></pre>"},{"location":"troubleshooting/migration/#from-unyt","title":"From unyt","text":""},{"location":"troubleshooting/migration/#key-differences_2","title":"Key Differences","text":"unyt dimtensor <code>unyt_array([1,2,3], 'm')</code> <code>DimArray([1,2,3], units.m)</code> <code>arr.v</code> or <code>arr.value</code> <code>arr.data</code> <code>arr.units</code> <code>arr.unit</code> <code>arr.to('km')</code> <code>arr.to(units.km)</code>"},{"location":"troubleshooting/migration/#before-unyt","title":"Before (unyt)","text":"<pre><code>from unyt import unyt_array\n\nvelocity = unyt_array([10, 20, 30], 'm/s')\ntime = unyt_array([1, 2, 3], 's')\ndistance = velocity * time\n\n# Get values\nvalues = velocity.v\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor_3","title":"After (dimtensor)","text":"<pre><code>from dimtensor import DimArray, units\n\nvelocity = DimArray([10, 20, 30], units.m / units.s)\ntime = DimArray([1, 2, 3], units.s)\ndistance = velocity * time\n\n# Get values\nvalues = velocity.data\n</code></pre>"},{"location":"troubleshooting/migration/#pytorch-migration","title":"PyTorch Migration","text":"<p>If you're adding units to PyTorch code:</p>"},{"location":"troubleshooting/migration/#before-raw-pytorch","title":"Before (Raw PyTorch)","text":"<pre><code>import torch\n\nmass = torch.tensor([1.0, 2.0], requires_grad=True)\nvelocity = torch.tensor([10.0, 20.0])\nenergy = 0.5 * mass * velocity**2\n\nloss = energy.sum()\nloss.backward()\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor_4","title":"After (dimtensor)","text":"<pre><code>import torch\nfrom dimtensor.torch import DimTensor\nfrom dimtensor import units\n\nmass = DimTensor(torch.tensor([1.0, 2.0], requires_grad=True), units.kg)\nvelocity = DimTensor(torch.tensor([10.0, 20.0]), units.m / units.s)\nenergy = 0.5 * mass * velocity**2  # Returns Joules\n\nloss = energy.sum()\nloss.backward()  # Gradients work!\n</code></pre>"},{"location":"troubleshooting/migration/#jax-migration","title":"JAX Migration","text":""},{"location":"troubleshooting/migration/#before-raw-jax","title":"Before (Raw JAX)","text":"<pre><code>import jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef kinetic_energy(mass, velocity):\n    return 0.5 * mass * velocity**2\n\nm = jnp.array([1.0, 2.0])\nv = jnp.array([10.0, 20.0])\nE = kinetic_energy(m, v)\n</code></pre>"},{"location":"troubleshooting/migration/#after-dimtensor_5","title":"After (dimtensor)","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom dimtensor.jax import DimArray\nfrom dimtensor import units\n\n@jax.jit\ndef kinetic_energy(mass, velocity):\n    return 0.5 * mass * velocity**2\n\nm = DimArray(jnp.array([1.0, 2.0]), units.kg)\nv = DimArray(jnp.array([10.0, 20.0]), units.m / units.s)\nE = kinetic_energy(m, v)  # JIT works, returns Joules\n</code></pre>"},{"location":"troubleshooting/migration/#common-patterns","title":"Common Patterns","text":""},{"location":"troubleshooting/migration/#wrapping-external-data","title":"Wrapping External Data","text":"<pre><code>import numpy as np\nfrom dimtensor import DimArray, units\n\n# Data from file, API, etc.\nraw_data = np.loadtxt(\"measurements.csv\")\n\n# Add units based on what you know about the data\ntemperatures = DimArray(raw_data[:, 0], units.K)\npressures = DimArray(raw_data[:, 1], units.Pa)\n</code></pre>"},{"location":"troubleshooting/migration/#interfacing-with-unit-unaware-libraries","title":"Interfacing with Unit-Unaware Libraries","text":"<pre><code>from dimtensor import DimArray, units\nimport scipy.optimize\n\ndef objective(x_raw):\n    # Convert raw values back to DimArray for physics\n    x = DimArray(x_raw, units.m)\n    # ... do unit-aware calculation ...\n    return result.data  # Return raw for scipy\n\n# scipy needs raw arrays\nx0 = initial_guess.data\nresult = scipy.optimize.minimize(objective, x0)\n</code></pre>"},{"location":"troubleshooting/migration/#gradual-migration","title":"Gradual Migration","text":"<p>You don't have to convert everything at once:</p> <pre><code>from dimtensor import DimArray, units\nimport numpy as np\n\n# Mix of old and new code\nold_array = np.array([1, 2, 3])  # Legacy code\nnew_array = DimArray([4, 5, 6], units.m)  # New code\n\n# Convert when needed\nold_with_units = DimArray(old_array, units.m)\ncombined = old_with_units + new_array\n</code></pre>"},{"location":"troubleshooting/migration/#getting-help","title":"Getting Help","text":"<p>If you run into issues during migration:</p> <ol> <li>Check Common Errors</li> <li>Check the FAQ</li> <li>Open an issue with your specific migration question</li> </ol>"}]}