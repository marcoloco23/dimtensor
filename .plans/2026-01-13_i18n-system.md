# Plan: Internationalization (i18n) System

**Date**: 2026-01-13
**Status**: PLANNING
**Author**: planner agent

---

## Goal

Design and implement a comprehensive internationalization system for dimtensor that supports multiple languages for unit names, error messages, CLI output, and documentation strings without impacting performance of core operations.

---

## Background

dimtensor is expanding its reach globally, particularly in education. Users in non-English-speaking countries would benefit from:
- Unit names in their native language (meter → metro, kilogram → kilogramo)
- Error messages they can understand
- Localized CLI output
- Documentation in their language

This is part of v5.1.0's Education & Accessibility focus.

---

## Approach

### Option A: Python gettext (Standard Library)

- Description: Use Python's built-in `gettext` module with `.po`/`.mo` files
- Pros:
  - Industry standard for Python i18n
  - Excellent tooling (Poedit, Transifex, Weblate)
  - Mature ecosystem
  - Free translation management platforms
  - Supports pluralization, context
- Cons:
  - Requires compilation step (.po → .mo)
  - More complex setup for unit translations
  - Binary .mo files harder to inspect
  - Overhead for simple string lookups

### Option B: JSON-based Translation Files

- Description: Custom lightweight system with JSON files for each locale
- Pros:
  - Simple to read and edit
  - No compilation step
  - Easy to inspect and debug
  - Direct mapping for unit symbols/names
  - Can be loaded lazily for performance
  - Fits with existing JSON serialization patterns in dimtensor
- Cons:
  - Custom solution to maintain
  - Less tooling support
  - No built-in pluralization (but not needed for units)
  - Translation platforms may need custom integration

### Option C: Hybrid Approach

- Description: JSON for units (fast lookup), gettext for messages (rich features)
- Pros:
  - Best of both worlds
  - Optimized for each use case
  - gettext for complex messages with pluralization
  - JSON for simple unit lookups
- Cons:
  - Two systems to maintain
  - More complex architecture
  - Potential confusion for contributors

### Decision: Option B (JSON) with future gettext migration path

**Rationale**:
1. **Performance**: Unit lookups happen frequently. JSON allows simple dict lookup with lazy loading
2. **Simplicity**: dimtensor already uses JSON for serialization (io/json.py)
3. **Transparency**: Scientists/educators can easily inspect and modify translations
4. **Gradual adoption**: Start with JSON, migrate to gettext later if needed
5. **Education focus**: Simple file format encourages community translations

Design JSON structure to be compatible with later gettext migration.

---

## Implementation Steps

### Phase 1: Core Infrastructure

1. [ ] Create `src/dimtensor/i18n/` module
2. [ ] Implement `locale.py`:
   - Locale detection (system locale, env vars)
   - Locale management (get/set current locale)
   - Fallback chain (es_MX → es → en)
   - Thread-safe locale storage
3. [ ] Implement `translations.py`:
   - Translation loader (lazy loading)
   - Translation registry
   - Cache management
   - Fallback mechanism
4. [ ] Create translation file structure:
   ```
   src/dimtensor/i18n/locales/
   ├── en.json (reference)
   ├── es.json (Spanish)
   ├── fr.json (French)
   ├── de.json (German)
   ├── zh_CN.json (Simplified Chinese)
   └── ja.json (Japanese)
   ```

### Phase 2: Unit Translation

5. [ ] Design JSON schema for unit translations:
   ```json
   {
     "units": {
       "m": {"symbol": "m", "name": "metro", "plural": "metros"},
       "kg": {"symbol": "kg", "name": "kilogramo", "plural": "kilogramos"}
     },
     "dimensions": {
       "length": "longitud",
       "mass": "masa",
       "time": "tiempo"
     }
   }
   ```
6. [ ] Add translation methods to `Unit` class:
   - `Unit.localized_name(locale=None)` → str
   - `Unit.localized_symbol(locale=None)` → str
7. [ ] Populate initial translations for 6 languages (EN, ES, FR, DE, ZH, JA)
8. [ ] Add `config.i18n` options:
   - `locale`: Current locale
   - `use_localized_units`: Enable/disable unit translation in display

### Phase 3: Error Message Translation

9. [ ] Add messages section to JSON:
   ```json
   {
     "errors": {
       "dimension_incompatible": "No se puede {operation} cantidades con dimensiones {left} y {right}",
       "unit_conversion_failed": "No se puede convertir de {from_unit} a {to_unit}"
     }
   }
   ```
10. [ ] Create `_()` translation function (gettext-compatible naming)
11. [ ] Update `errors.py` to use `_()`
12. [ ] Add context parameter support for ambiguous translations

### Phase 4: CLI Translation

13. [ ] Add CLI messages to JSON:
    ```json
    {
      "cli": {
        "lint": {
          "checking_file": "Verificando archivo: {filename}",
          "found_issues": "Se encontraron {count} problemas"
        }
      }
    }
    ```
14. [ ] Update `cli/lint.py` to use translations
15. [ ] Add `--locale` CLI flag

### Phase 5: Configuration Integration

16. [ ] Add i18n configuration to `config.py`:
    ```python
    @dataclass
    class I18nOptions:
        locale: str | None = None  # None = auto-detect
        use_localized_units: bool = True
        use_localized_errors: bool = True
        fallback_locale: str = "en"
    ```
17. [ ] Add context manager `config.locale(locale_code)`
18. [ ] Ensure thread-safety for locale switching

### Phase 6: Performance Optimization

19. [ ] Implement translation caching
20. [ ] Add lazy loading (don't load all locales at startup)
21. [ ] Add benchmarks comparing with/without i18n
22. [ ] Optimize hot paths (unit operations should not call translation)
23. [ ] Only translate on display/error formatting, not during computation

### Phase 7: Testing & Documentation

24. [ ] Unit tests for locale detection
25. [ ] Unit tests for translation loading/fallback
26. [ ] Integration tests with all supported locales
27. [ ] Performance regression tests
28. [ ] Add i18n guide to docs
29. [ ] Add contribution guide for translators
30. [ ] Add examples showing locale switching

---

## Files to Modify

| File | Change |
|------|--------|
| `src/dimtensor/i18n/__init__.py` | New: Public API exports |
| `src/dimtensor/i18n/locale.py` | New: Locale detection and management |
| `src/dimtensor/i18n/translations.py` | New: Translation loading and lookup |
| `src/dimtensor/i18n/locales/*.json` | New: Translation files |
| `src/dimtensor/core/units.py` | Add: `localized_name()`, `localized_symbol()` methods |
| `src/dimtensor/errors.py` | Modify: Use `_()` for all error messages |
| `src/dimtensor/config.py` | Add: `I18nOptions` dataclass and context manager |
| `src/dimtensor/cli/lint.py` | Modify: Use translations for output |
| `tests/i18n/test_locale.py` | New: Locale tests |
| `tests/i18n/test_translations.py` | New: Translation tests |
| `tests/i18n/test_units_i18n.py` | New: Unit translation tests |
| `tests/i18n/test_performance.py` | New: Performance regression tests |
| `pyproject.toml` | Modify: Add i18n package data |

---

## Testing Strategy

### Unit Tests

- [ ] Test locale detection from system/env
- [ ] Test locale setting/getting
- [ ] Test fallback chain (es_MX → es → en)
- [ ] Test translation loading
- [ ] Test missing translation fallback
- [ ] Test translation caching
- [ ] Test thread-safety of locale switching

### Integration Tests

- [ ] Test unit name translation for all locales
- [ ] Test error message translation
- [ ] Test CLI output in different locales
- [ ] Test mixed locale scenarios
- [ ] Test context manager `with config.locale('es'):`

### Performance Tests

- [ ] Benchmark: Unit operations with/without i18n enabled
- [ ] Benchmark: Translation lookup performance
- [ ] Benchmark: Lazy loading vs eager loading
- [ ] Ensure <5% overhead on core operations
- [ ] Profile memory usage with multiple locales

### Manual Verification

- [ ] Verify translations with native speakers
- [ ] Test on different operating systems (Windows, macOS, Linux)
- [ ] Test with different system locales
- [ ] Verify fallback behavior in edge cases

---

## Risks / Edge Cases

### Risk 1: Performance Degradation
- **Impact**: Slowing down core tensor operations
- **Mitigation**:
  - Only translate during display/error formatting, not computation
  - Cache translations aggressively
  - Use lazy loading for locale files
  - Benchmark and set <5% overhead requirement

### Risk 2: Incomplete Translations
- **Impact**: Users see mixed languages
- **Mitigation**:
  - Always fallback to English for missing translations
  - Clear contribution guide for translators
  - Validation script to check translation completeness
  - Start with high-priority strings (errors, common units)

### Risk 3: Thread Safety Issues
- **Impact**: Race conditions with locale switching
- **Mitigation**:
  - Use threading.local() for per-thread locale
  - Document thread-safety guarantees
  - Test concurrent locale switching

### Risk 4: Unit Symbol Ambiguity
- **Impact**: Some languages may prefer different symbols (°C vs ℃)
- **Mitigation**:
  - Keep symbols consistent (ASCII preferred)
  - Only translate full names by default
  - Make symbol translation opt-in

### Risk 5: Complex Pluralization
- **Impact**: Some languages have complex plural rules
- **Mitigation**:
  - JSON format includes singular/plural forms
  - Keep most strings singular (unit names in isolation)
  - For future: add pluralization rules per locale

### Edge Case: Regional Variants
- **Handling**: Support fallback es_MX → es → en
- **Implementation**: Parse locale codes properly (language_REGION)

### Edge Case: Right-to-Left Languages
- **Handling**: Not in initial scope, document as future work
- **Note**: JSON structure supports RTL when needed

### Edge Case: Encoding Issues
- **Handling**: Use UTF-8 for all JSON files, test with emoji/special chars
- **Validation**: CI checks for valid UTF-8 encoding

---

## Definition of Done

- [ ] All implementation steps complete
- [ ] Core infrastructure (locale, translations) implemented
- [ ] 6 languages supported (EN, ES, FR, DE, ZH_CN, JA)
- [ ] Unit names translated
- [ ] Error messages translated
- [ ] CLI output translated
- [ ] Configuration system integrated
- [ ] Performance tests pass (<5% overhead)
- [ ] All tests pass
- [ ] Documentation updated (i18n guide, API docs)
- [ ] Examples added showing locale switching
- [ ] Contribution guide for translators
- [ ] CONTINUITY.md updated

---

## JSON Schema Design

### Translation File Schema (locale.json)

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "version": "1.0",
  "locale": "es",
  "language": "español",
  "translator": "Community",

  "dimensions": {
    "length": "longitud",
    "mass": "masa",
    "time": "tiempo",
    "current": "corriente eléctrica",
    "temperature": "temperatura",
    "amount": "cantidad de sustancia",
    "luminosity": "intensidad luminosa"
  },

  "units": {
    "m": {
      "symbol": "m",
      "name": "metro",
      "name_plural": "metros"
    },
    "kg": {
      "symbol": "kg",
      "name": "kilogramo",
      "name_plural": "kilogramos"
    },
    "s": {
      "symbol": "s",
      "name": "segundo",
      "name_plural": "segundos"
    }
  },

  "errors": {
    "dimension_incompatible": "No se puede {operation} cantidades con dimensiones {left} y {right}",
    "unit_conversion_incompatible": "No se puede convertir de {from_unit} a {to_unit}: dimensiones incompatibles",
    "constraint_violated": "Restricción '{constraint}' violada"
  },

  "cli": {
    "checking_file": "Verificando archivo: {filename}",
    "issues_found": "Encontrados {count} problemas",
    "no_issues": "No se encontraron problemas"
  },

  "messages": {
    "conversion_warning": "Advertencia: conversión de {from_unit} a {to_unit}",
    "inference_suggestion": "Sugerencia: la variable '{name}' podría tener dimensión {dimension}"
  }
}
```

---

## API Design

### Public API (`src/dimtensor/i18n/__init__.py`)

```python
# Locale management
def get_locale() -> str
def set_locale(locale: str) -> None
def detect_locale() -> str
def available_locales() -> list[str]

# Translation functions
def _(message: str, **kwargs) -> str  # gettext-compatible name
def translate(message: str, locale: str | None = None, **kwargs) -> str

# Unit translation
def translate_unit_name(symbol: str, locale: str | None = None) -> str
def translate_dimension_name(dim_name: str, locale: str | None = None) -> str
```

### Integration with existing classes

```python
# In Unit class
class Unit:
    def localized_name(self, locale: str | None = None, plural: bool = False) -> str:
        """Get localized unit name."""
        ...

    def localized_symbol(self, locale: str | None = None) -> str:
        """Get localized symbol (usually same as original)."""
        ...

# In config.py
@dataclass
class I18nOptions:
    locale: str | None = None  # None = auto-detect
    use_localized_units: bool = True
    use_localized_errors: bool = True
    fallback_locale: str = "en"

i18n = I18nOptions()

@contextmanager
def locale(code: str) -> Iterator[None]:
    """Temporarily switch locale."""
    ...
```

---

## Performance Targets

- Unit operations: <2% overhead (should be ~0% - no translation during compute)
- Translation lookup: <10μs per call (with caching)
- Locale switching: <1ms
- Memory per loaded locale: <100KB
- Startup time increase: <50ms

---

## Initial Language Priority

1. **English (en)**: Reference implementation, 100% complete
2. **Spanish (es)**: Large user base, Latin America + Spain
3. **French (fr)**: Common in science/education
4. **German (de)**: Strong engineering/physics tradition
5. **Chinese (zh_CN)**: Large user base, growing scientific community
6. **Japanese (ja)**: Strong physics/engineering community

Future additions:
- Portuguese (pt_BR)
- Russian (ru)
- Italian (it)
- Korean (ko)
- Arabic (ar) - requires RTL support planning

---

## Notes / Log

**2026-01-13** - Initial plan created by planner agent

Key decisions:
- JSON over gettext for simplicity and performance
- Lazy loading to minimize overhead
- Translation only on display, never during computation
- Thread-safe locale management with thread-local storage
- Comprehensive fallback chain for regional variants
- 6 languages in initial release

Next steps:
- Review plan with team
- Get approval on JSON schema
- Identify translators for initial 6 languages
- Begin implementation with core infrastructure

---
